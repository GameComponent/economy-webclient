/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Economy service
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.0
 * Contact: info@gamecomponent.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "http://localhost".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *  
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * `ListValue` is a wrapper around a repeated field of values.  The JSON representation for `ListValue` is JSON array.
 * @export
 * @interface ProtobufListValue
 */
export interface ProtobufListValue {
    /**
     * Repeated field of dynamically typed values.
     * @type {Array<ProtobufValue>}
     * @memberof ProtobufListValue
     */
    values?: Array<ProtobufValue>;
}

/**
 * `NullValue` is a singleton enumeration to represent the null value for the `Value` type union.   The JSON representation for `NullValue` is JSON `null`.   - NULL_VALUE: Null value.
 * @export
 * @enum {string}
 */
export enum ProtobufNullValue {
    NULLVALUE = <any> 'NULL_VALUE'
}

/**
 * `Struct` represents a structured data value, consisting of fields which map to dynamically typed values. In some languages, `Struct` might be supported by a native representation. For example, in scripting languages like JS a struct is represented as an object. The details of that representation are described together with the proto support for the language.  The JSON representation for `Struct` is JSON object.
 * @export
 * @interface ProtobufStruct
 */
export interface ProtobufStruct {
    /**
     * Unordered map of dynamically typed values.
     * @type {{ [key: string]: ProtobufValue; }}
     * @memberof ProtobufStruct
     */
    fields?: { [key: string]: ProtobufValue; };
}

/**
 * `Value` represents a dynamically typed value which can be either null, a number, a string, a boolean, a recursive struct value, or a list of values. A producer of value is expected to set one of that variants, absence of any variant indicates an error.  The JSON representation for `Value` is JSON value.
 * @export
 * @interface ProtobufValue
 */
export interface ProtobufValue {
    /**
     * Represents a null value.
     * @type {ProtobufNullValue}
     * @memberof ProtobufValue
     */
    nullValue?: ProtobufNullValue;
    /**
     * Represents a double value.
     * @type {number}
     * @memberof ProtobufValue
     */
    numberValue?: number;
    /**
     * Represents a string value.
     * @type {string}
     * @memberof ProtobufValue
     */
    stringValue?: string;
    /**
     * Represents a boolean value.
     * @type {boolean}
     * @memberof ProtobufValue
     */
    boolValue?: boolean;
    /**
     * Represents a structured value.
     * @type {ProtobufStruct}
     * @memberof ProtobufValue
     */
    structValue?: ProtobufStruct;
    /**
     * Represents a repeated `Value`.
     * @type {ProtobufListValue}
     * @memberof ProtobufValue
     */
    listValue?: ProtobufListValue;
}

/**
 * 
 * @export
 * @interface V1CreateCurrencyRequest
 */
export interface V1CreateCurrencyRequest {
    /**
     * 
     * @type {string}
     * @memberof V1CreateCurrencyRequest
     */
    api?: string;
    /**
     * 
     * @type {string}
     * @memberof V1CreateCurrencyRequest
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface V1CreateCurrencyResponse
 */
export interface V1CreateCurrencyResponse {
    /**
     * 
     * @type {string}
     * @memberof V1CreateCurrencyResponse
     */
    api?: string;
    /**
     * 
     * @type {V1Currency}
     * @memberof V1CreateCurrencyResponse
     */
    currency?: V1Currency;
}

/**
 * 
 * @export
 * @interface V1CreateItemRequest
 */
export interface V1CreateItemRequest {
    /**
     * 
     * @type {string}
     * @memberof V1CreateItemRequest
     */
    api?: string;
    /**
     * 
     * @type {string}
     * @memberof V1CreateItemRequest
     */
    name?: string;
    /**
     * 
     * @type {ProtobufStruct}
     * @memberof V1CreateItemRequest
     */
    metadata?: ProtobufStruct;
}

/**
 * 
 * @export
 * @interface V1CreateItemResponse
 */
export interface V1CreateItemResponse {
    /**
     * 
     * @type {string}
     * @memberof V1CreateItemResponse
     */
    api?: string;
    /**
     * 
     * @type {V1Item}
     * @memberof V1CreateItemResponse
     */
    item?: V1Item;
}

/**
 * 
 * @export
 * @interface V1CreateStorageRequest
 */
export interface V1CreateStorageRequest {
    /**
     * 
     * @type {string}
     * @memberof V1CreateStorageRequest
     */
    api?: string;
    /**
     * 
     * @type {string}
     * @memberof V1CreateStorageRequest
     */
    playerId?: string;
    /**
     * 
     * @type {string}
     * @memberof V1CreateStorageRequest
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface V1CreateStorageResponse
 */
export interface V1CreateStorageResponse {
    /**
     * 
     * @type {string}
     * @memberof V1CreateStorageResponse
     */
    api?: string;
    /**
     * 
     * @type {V1Storage}
     * @memberof V1CreateStorageResponse
     */
    storage?: V1Storage;
}

/**
 * 
 * @export
 * @interface V1Currency
 */
export interface V1Currency {
    /**
     * 
     * @type {string}
     * @memberof V1Currency
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Currency
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Currency
     */
    shortName?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Currency
     */
    symbol?: string;
}

/**
 * 
 * @export
 * @interface V1GetCurrencyResponse
 */
export interface V1GetCurrencyResponse {
    /**
     * 
     * @type {string}
     * @memberof V1GetCurrencyResponse
     */
    api?: string;
    /**
     * 
     * @type {V1Currency}
     * @memberof V1GetCurrencyResponse
     */
    currency?: V1Currency;
}

/**
 * 
 * @export
 * @interface V1GetItemResponse
 */
export interface V1GetItemResponse {
    /**
     * 
     * @type {string}
     * @memberof V1GetItemResponse
     */
    api?: string;
    /**
     * 
     * @type {V1Item}
     * @memberof V1GetItemResponse
     */
    item?: V1Item;
}

/**
 * 
 * @export
 * @interface V1GetPlayerResponse
 */
export interface V1GetPlayerResponse {
    /**
     * 
     * @type {string}
     * @memberof V1GetPlayerResponse
     */
    api?: string;
    /**
     * 
     * @type {V1Player}
     * @memberof V1GetPlayerResponse
     */
    player?: V1Player;
}

/**
 * 
 * @export
 * @interface V1GetStorageResponse
 */
export interface V1GetStorageResponse {
    /**
     * 
     * @type {string}
     * @memberof V1GetStorageResponse
     */
    api?: string;
    /**
     * 
     * @type {V1Storage}
     * @memberof V1GetStorageResponse
     */
    storage?: V1Storage;
}

/**
 * 
 * @export
 * @interface V1GiveCurrencyRequest
 */
export interface V1GiveCurrencyRequest {
    /**
     * 
     * @type {string}
     * @memberof V1GiveCurrencyRequest
     */
    api?: string;
    /**
     * 
     * @type {string}
     * @memberof V1GiveCurrencyRequest
     */
    storageId?: string;
    /**
     * 
     * @type {string}
     * @memberof V1GiveCurrencyRequest
     */
    currencyId?: string;
    /**
     * 
     * @type {string}
     * @memberof V1GiveCurrencyRequest
     */
    amount?: string;
}

/**
 * 
 * @export
 * @interface V1GiveCurrencyResponse
 */
export interface V1GiveCurrencyResponse {
    /**
     * 
     * @type {string}
     * @memberof V1GiveCurrencyResponse
     */
    api?: string;
    /**
     * 
     * @type {V1StorageCurrency}
     * @memberof V1GiveCurrencyResponse
     */
    currency?: V1StorageCurrency;
}

/**
 * 
 * @export
 * @interface V1GiveItemRequest
 */
export interface V1GiveItemRequest {
    /**
     * 
     * @type {string}
     * @memberof V1GiveItemRequest
     */
    api?: string;
    /**
     * 
     * @type {string}
     * @memberof V1GiveItemRequest
     */
    storageId?: string;
    /**
     * 
     * @type {string}
     * @memberof V1GiveItemRequest
     */
    itemId?: string;
    /**
     * 
     * @type {ProtobufStruct}
     * @memberof V1GiveItemRequest
     */
    metadata?: ProtobufStruct;
}

/**
 * 
 * @export
 * @interface V1GiveItemResponse
 */
export interface V1GiveItemResponse {
    /**
     * 
     * @type {string}
     * @memberof V1GiveItemResponse
     */
    api?: string;
    /**
     * 
     * @type {string}
     * @memberof V1GiveItemResponse
     */
    storageId?: string;
    /**
     * 
     * @type {V1StorageItem}
     * @memberof V1GiveItemResponse
     */
    item?: V1StorageItem;
}

/**
 * 
 * @export
 * @interface V1Item
 */
export interface V1Item {
    /**
     * 
     * @type {string}
     * @memberof V1Item
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Item
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface V1ListCurrencyResponse
 */
export interface V1ListCurrencyResponse {
    /**
     * 
     * @type {string}
     * @memberof V1ListCurrencyResponse
     */
    api?: string;
    /**
     * 
     * @type {Array<V1Currency>}
     * @memberof V1ListCurrencyResponse
     */
    currencies?: Array<V1Currency>;
}

/**
 * 
 * @export
 * @interface V1ListItemsResponse
 */
export interface V1ListItemsResponse {
    /**
     * 
     * @type {string}
     * @memberof V1ListItemsResponse
     */
    api?: string;
    /**
     * 
     * @type {Array<V1Item>}
     * @memberof V1ListItemsResponse
     */
    items?: Array<V1Item>;
}

/**
 * 
 * @export
 * @interface V1Player
 */
export interface V1Player {
    /**
     * 
     * @type {string}
     * @memberof V1Player
     */
    id?: string;
    /**
     * 
     * @type {Array<V1StorageBase>}
     * @memberof V1Player
     */
    storages?: Array<V1StorageBase>;
}

/**
 * 
 * @export
 * @interface V1Storage
 */
export interface V1Storage {
    /**
     * 
     * @type {string}
     * @memberof V1Storage
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Storage
     */
    playerId?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Storage
     */
    name?: string;
    /**
     * 
     * @type {Array<V1StorageItem>}
     * @memberof V1Storage
     */
    items?: Array<V1StorageItem>;
}

/**
 * 
 * @export
 * @interface V1StorageBase
 */
export interface V1StorageBase {
    /**
     * 
     * @type {string}
     * @memberof V1StorageBase
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof V1StorageBase
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface V1StorageCurrency
 */
export interface V1StorageCurrency {
    /**
     * 
     * @type {string}
     * @memberof V1StorageCurrency
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof V1StorageCurrency
     */
    currencyId?: string;
    /**
     * 
     * @type {string}
     * @memberof V1StorageCurrency
     */
    amount?: string;
}

/**
 * 
 * @export
 * @interface V1StorageItem
 */
export interface V1StorageItem {
    /**
     * 
     * @type {string}
     * @memberof V1StorageItem
     */
    id?: string;
    /**
     * 
     * @type {V1Item}
     * @memberof V1StorageItem
     */
    item?: V1Item;
}

/**
 * 
 * @export
 * @interface V1UpdateItemRequest
 */
export interface V1UpdateItemRequest {
    /**
     * 
     * @type {string}
     * @memberof V1UpdateItemRequest
     */
    api?: string;
    /**
     * 
     * @type {string}
     * @memberof V1UpdateItemRequest
     */
    itemId?: string;
    /**
     * 
     * @type {string}
     * @memberof V1UpdateItemRequest
     */
    name?: string;
    /**
     * 
     * @type {ProtobufStruct}
     * @memberof V1UpdateItemRequest
     */
    metadata?: ProtobufStruct;
}

/**
 * 
 * @export
 * @interface V1UpdateItemResponse
 */
export interface V1UpdateItemResponse {
    /**
     * 
     * @type {string}
     * @memberof V1UpdateItemResponse
     */
    api?: string;
    /**
     * 
     * @type {V1Item}
     * @memberof V1UpdateItemResponse
     */
    item?: V1Item;
}


/**
 * EconomyServiceApi - fetch parameter creator
 * @export
 */
export const EconomyServiceApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a currency
         * @param {V1CreateCurrencyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCurrency(body: V1CreateCurrencyRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createCurrency.');
            }
            const localVarPath = `/v1/currency`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1CreateCurrencyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create an Item
         * @param {V1CreateItemRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItem(body: V1CreateItemRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createItem.');
            }
            const localVarPath = `/v1/item`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1CreateItemRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new Storage
         * @param {V1CreateStorageRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStorage(body: V1CreateStorageRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createStorage.');
            }
            const localVarPath = `/v1/storage`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1CreateStorageRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a currency
         * @param {string} currencyId 
         * @param {string} [api] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrency(currencyId: string, api?: string, options: any = {}): FetchArgs {
            // verify required parameter 'currencyId' is not null or undefined
            if (currencyId === null || currencyId === undefined) {
                throw new RequiredError('currencyId','Required parameter currencyId was null or undefined when calling getCurrency.');
            }
            const localVarPath = `/v1/currency/{currencyId}`
                .replace(`{${"currencyId"}}`, encodeURIComponent(String(currencyId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (api !== undefined) {
                localVarQueryParameter['api'] = api;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get an Item
         * @param {string} itemId 
         * @param {string} [api] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItem(itemId: string, api?: string, options: any = {}): FetchArgs {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getItem.');
            }
            const localVarPath = `/v1/item/{itemId}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (api !== undefined) {
                localVarQueryParameter['api'] = api;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary TODO: Wrap in Player struct To see what Storages belong to an User
         * @param {string} playerId 
         * @param {string} [api] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayer(playerId: string, api?: string, options: any = {}): FetchArgs {
            // verify required parameter 'playerId' is not null or undefined
            if (playerId === null || playerId === undefined) {
                throw new RequiredError('playerId','Required parameter playerId was null or undefined when calling getPlayer.');
            }
            const localVarPath = `/v1/player/{playerId}`
                .replace(`{${"playerId"}}`, encodeURIComponent(String(playerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (api !== undefined) {
                localVarQueryParameter['api'] = api;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the contents of a storage
         * @param {string} storageId 
         * @param {string} [api] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorage(storageId: string, api?: string, options: any = {}): FetchArgs {
            // verify required parameter 'storageId' is not null or undefined
            if (storageId === null || storageId === undefined) {
                throw new RequiredError('storageId','Required parameter storageId was null or undefined when calling getStorage.');
            }
            const localVarPath = `/v1/storage/{storageId}`
                .replace(`{${"storageId"}}`, encodeURIComponent(String(storageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (api !== undefined) {
                localVarQueryParameter['api'] = api;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Give an amount of Currency to a Storage
         * @param {V1GiveCurrencyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giveCurrency(body: V1GiveCurrencyRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling giveCurrency.');
            }
            const localVarPath = `/v1/storage/give/currency`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1GiveCurrencyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Give Item to a Storage
         * @param {V1GiveItemRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giveItem(body: V1GiveItemRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling giveItem.');
            }
            const localVarPath = `/v1/storage/give/item`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1GiveItemRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Shows all currencies
         * @param {string} [api] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCurrency(api?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v1/currency`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (api !== undefined) {
                localVarQueryParameter['api'] = api;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all Items
         * @param {string} [api] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listItems(api?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v1/items`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (api !== undefined) {
                localVarQueryParameter['api'] = api;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an Item
         * @param {V1UpdateItemRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItem(body: V1UpdateItemRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateItem.');
            }
            const localVarPath = `/v1/item`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1UpdateItemRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EconomyServiceApi - functional programming interface
 * @export
 */
export const EconomyServiceApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a currency
         * @param {V1CreateCurrencyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCurrency(body: V1CreateCurrencyRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1CreateCurrencyResponse> {
            const localVarFetchArgs = EconomyServiceApiFetchParamCreator(configuration).createCurrency(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create an Item
         * @param {V1CreateItemRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItem(body: V1CreateItemRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1CreateItemResponse> {
            const localVarFetchArgs = EconomyServiceApiFetchParamCreator(configuration).createItem(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create a new Storage
         * @param {V1CreateStorageRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStorage(body: V1CreateStorageRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1CreateStorageResponse> {
            const localVarFetchArgs = EconomyServiceApiFetchParamCreator(configuration).createStorage(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a currency
         * @param {string} currencyId 
         * @param {string} [api] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrency(currencyId: string, api?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetCurrencyResponse> {
            const localVarFetchArgs = EconomyServiceApiFetchParamCreator(configuration).getCurrency(currencyId, api, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get an Item
         * @param {string} itemId 
         * @param {string} [api] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItem(itemId: string, api?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetItemResponse> {
            const localVarFetchArgs = EconomyServiceApiFetchParamCreator(configuration).getItem(itemId, api, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary TODO: Wrap in Player struct To see what Storages belong to an User
         * @param {string} playerId 
         * @param {string} [api] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayer(playerId: string, api?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetPlayerResponse> {
            const localVarFetchArgs = EconomyServiceApiFetchParamCreator(configuration).getPlayer(playerId, api, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the contents of a storage
         * @param {string} storageId 
         * @param {string} [api] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorage(storageId: string, api?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetStorageResponse> {
            const localVarFetchArgs = EconomyServiceApiFetchParamCreator(configuration).getStorage(storageId, api, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Give an amount of Currency to a Storage
         * @param {V1GiveCurrencyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giveCurrency(body: V1GiveCurrencyRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GiveCurrencyResponse> {
            const localVarFetchArgs = EconomyServiceApiFetchParamCreator(configuration).giveCurrency(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Give Item to a Storage
         * @param {V1GiveItemRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giveItem(body: V1GiveItemRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GiveItemResponse> {
            const localVarFetchArgs = EconomyServiceApiFetchParamCreator(configuration).giveItem(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Shows all currencies
         * @param {string} [api] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCurrency(api?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListCurrencyResponse> {
            const localVarFetchArgs = EconomyServiceApiFetchParamCreator(configuration).listCurrency(api, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List all Items
         * @param {string} [api] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listItems(api?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListItemsResponse> {
            const localVarFetchArgs = EconomyServiceApiFetchParamCreator(configuration).listItems(api, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update an Item
         * @param {V1UpdateItemRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItem(body: V1UpdateItemRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1UpdateItemResponse> {
            const localVarFetchArgs = EconomyServiceApiFetchParamCreator(configuration).updateItem(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EconomyServiceApi - factory interface
 * @export
 */
export const EconomyServiceApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create a currency
         * @param {V1CreateCurrencyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCurrency(body: V1CreateCurrencyRequest, options?: any) {
            return EconomyServiceApiFp(configuration).createCurrency(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create an Item
         * @param {V1CreateItemRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItem(body: V1CreateItemRequest, options?: any) {
            return EconomyServiceApiFp(configuration).createItem(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a new Storage
         * @param {V1CreateStorageRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStorage(body: V1CreateStorageRequest, options?: any) {
            return EconomyServiceApiFp(configuration).createStorage(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a currency
         * @param {string} currencyId 
         * @param {string} [api] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrency(currencyId: string, api?: string, options?: any) {
            return EconomyServiceApiFp(configuration).getCurrency(currencyId, api, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get an Item
         * @param {string} itemId 
         * @param {string} [api] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItem(itemId: string, api?: string, options?: any) {
            return EconomyServiceApiFp(configuration).getItem(itemId, api, options)(fetch, basePath);
        },
        /**
         * 
         * @summary TODO: Wrap in Player struct To see what Storages belong to an User
         * @param {string} playerId 
         * @param {string} [api] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayer(playerId: string, api?: string, options?: any) {
            return EconomyServiceApiFp(configuration).getPlayer(playerId, api, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the contents of a storage
         * @param {string} storageId 
         * @param {string} [api] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorage(storageId: string, api?: string, options?: any) {
            return EconomyServiceApiFp(configuration).getStorage(storageId, api, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Give an amount of Currency to a Storage
         * @param {V1GiveCurrencyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giveCurrency(body: V1GiveCurrencyRequest, options?: any) {
            return EconomyServiceApiFp(configuration).giveCurrency(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Give Item to a Storage
         * @param {V1GiveItemRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giveItem(body: V1GiveItemRequest, options?: any) {
            return EconomyServiceApiFp(configuration).giveItem(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Shows all currencies
         * @param {string} [api] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCurrency(api?: string, options?: any) {
            return EconomyServiceApiFp(configuration).listCurrency(api, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List all Items
         * @param {string} [api] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listItems(api?: string, options?: any) {
            return EconomyServiceApiFp(configuration).listItems(api, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an Item
         * @param {V1UpdateItemRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItem(body: V1UpdateItemRequest, options?: any) {
            return EconomyServiceApiFp(configuration).updateItem(body, options)(fetch, basePath);
        },
    };
};

/**
 * EconomyServiceApi - object-oriented interface
 * @export
 * @class EconomyServiceApi
 * @extends {BaseAPI}
 */
export class EconomyServiceApi extends BaseAPI {
    /**
     * 
     * @summary Create a currency
     * @param {V1CreateCurrencyRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyServiceApi
     */
    public createCurrency(body: V1CreateCurrencyRequest, options?: any) {
        return EconomyServiceApiFp(this.configuration).createCurrency(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create an Item
     * @param {V1CreateItemRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyServiceApi
     */
    public createItem(body: V1CreateItemRequest, options?: any) {
        return EconomyServiceApiFp(this.configuration).createItem(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create a new Storage
     * @param {V1CreateStorageRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyServiceApi
     */
    public createStorage(body: V1CreateStorageRequest, options?: any) {
        return EconomyServiceApiFp(this.configuration).createStorage(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a currency
     * @param {string} currencyId 
     * @param {string} [api] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyServiceApi
     */
    public getCurrency(currencyId: string, api?: string, options?: any) {
        return EconomyServiceApiFp(this.configuration).getCurrency(currencyId, api, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get an Item
     * @param {string} itemId 
     * @param {string} [api] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyServiceApi
     */
    public getItem(itemId: string, api?: string, options?: any) {
        return EconomyServiceApiFp(this.configuration).getItem(itemId, api, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary TODO: Wrap in Player struct To see what Storages belong to an User
     * @param {string} playerId 
     * @param {string} [api] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyServiceApi
     */
    public getPlayer(playerId: string, api?: string, options?: any) {
        return EconomyServiceApiFp(this.configuration).getPlayer(playerId, api, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the contents of a storage
     * @param {string} storageId 
     * @param {string} [api] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyServiceApi
     */
    public getStorage(storageId: string, api?: string, options?: any) {
        return EconomyServiceApiFp(this.configuration).getStorage(storageId, api, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Give an amount of Currency to a Storage
     * @param {V1GiveCurrencyRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyServiceApi
     */
    public giveCurrency(body: V1GiveCurrencyRequest, options?: any) {
        return EconomyServiceApiFp(this.configuration).giveCurrency(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Give Item to a Storage
     * @param {V1GiveItemRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyServiceApi
     */
    public giveItem(body: V1GiveItemRequest, options?: any) {
        return EconomyServiceApiFp(this.configuration).giveItem(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Shows all currencies
     * @param {string} [api] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyServiceApi
     */
    public listCurrency(api?: string, options?: any) {
        return EconomyServiceApiFp(this.configuration).listCurrency(api, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List all Items
     * @param {string} [api] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyServiceApi
     */
    public listItems(api?: string, options?: any) {
        return EconomyServiceApiFp(this.configuration).listItems(api, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update an Item
     * @param {V1UpdateItemRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyServiceApi
     */
    public updateItem(body: V1UpdateItemRequest, options?: any) {
        return EconomyServiceApiFp(this.configuration).updateItem(body, options)(this.fetch, this.basePath);
    }

}

