/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Economy service
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.0
 * Contact: info@gamecomponent.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "http://localhost".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *  
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface V1Account
 */
export interface V1Account {
    /**
     * 
     * @type {string}
     * @memberof V1Account
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Account
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Account
     */
    hash?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1Account
     */
    permissions?: Array<string>;
}

/**
 * 
 * @export
 * @interface V1Amount
 */
export interface V1Amount {
    /**
     * 
     * @type {string}
     * @memberof V1Amount
     */
    minAmount?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Amount
     */
    maxAmount?: string;
}

/**
 * 
 * @export
 * @interface V1AssignPermissionRequest
 */
export interface V1AssignPermissionRequest {
    /**
     * 
     * @type {string}
     * @memberof V1AssignPermissionRequest
     */
    accountId?: string;
    /**
     * 
     * @type {string}
     * @memberof V1AssignPermissionRequest
     */
    permission?: string;
}

/**
 * 
 * @export
 * @interface V1AssignPermissionResponse
 */
export interface V1AssignPermissionResponse {
    /**
     * 
     * @type {V1Account}
     * @memberof V1AssignPermissionResponse
     */
    account?: V1Account;
}

/**
 * 
 * @export
 * @interface V1AttachCurrencyRequest
 */
export interface V1AttachCurrencyRequest {
    /**
     * 
     * @type {string}
     * @memberof V1AttachCurrencyRequest
     */
    productId?: string;
    /**
     * 
     * @type {string}
     * @memberof V1AttachCurrencyRequest
     */
    currencyId?: string;
    /**
     * 
     * @type {string}
     * @memberof V1AttachCurrencyRequest
     */
    amount?: string;
}

/**
 * 
 * @export
 * @interface V1AttachCurrencyResponse
 */
export interface V1AttachCurrencyResponse {
    /**
     * 
     * @type {V1Product}
     * @memberof V1AttachCurrencyResponse
     */
    product?: V1Product;
}

/**
 * 
 * @export
 * @interface V1AttachItemRequest
 */
export interface V1AttachItemRequest {
    /**
     * 
     * @type {string}
     * @memberof V1AttachItemRequest
     */
    productId?: string;
    /**
     * 
     * @type {string}
     * @memberof V1AttachItemRequest
     */
    itemId?: string;
    /**
     * 
     * @type {string}
     * @memberof V1AttachItemRequest
     */
    amount?: string;
}

/**
 * 
 * @export
 * @interface V1AttachItemResponse
 */
export interface V1AttachItemResponse {
    /**
     * 
     * @type {V1Product}
     * @memberof V1AttachItemResponse
     */
    product?: V1Product;
}

/**
 * 
 * @export
 * @interface V1AttachPriceCurrencyRequest
 */
export interface V1AttachPriceCurrencyRequest {
    /**
     * 
     * @type {string}
     * @memberof V1AttachPriceCurrencyRequest
     */
    priceId?: string;
    /**
     * 
     * @type {string}
     * @memberof V1AttachPriceCurrencyRequest
     */
    currencyId?: string;
    /**
     * 
     * @type {string}
     * @memberof V1AttachPriceCurrencyRequest
     */
    amount?: string;
}

/**
 * 
 * @export
 * @interface V1AttachPriceCurrencyResponse
 */
export interface V1AttachPriceCurrencyResponse {
    /**
     * 
     * @type {V1Price}
     * @memberof V1AttachPriceCurrencyResponse
     */
    price?: V1Price;
}

/**
 * 
 * @export
 * @interface V1AttachPriceItemRequest
 */
export interface V1AttachPriceItemRequest {
    /**
     * 
     * @type {string}
     * @memberof V1AttachPriceItemRequest
     */
    priceId?: string;
    /**
     * 
     * @type {string}
     * @memberof V1AttachPriceItemRequest
     */
    itemId?: string;
    /**
     * 
     * @type {string}
     * @memberof V1AttachPriceItemRequest
     */
    amount?: string;
}

/**
 * 
 * @export
 * @interface V1AttachPriceItemResponse
 */
export interface V1AttachPriceItemResponse {
    /**
     * 
     * @type {V1Price}
     * @memberof V1AttachPriceItemResponse
     */
    price?: V1Price;
}

/**
 * 
 * @export
 * @interface V1AttachProductRequest
 */
export interface V1AttachProductRequest {
    /**
     * 
     * @type {string}
     * @memberof V1AttachProductRequest
     */
    shopId?: string;
    /**
     * 
     * @type {string}
     * @memberof V1AttachProductRequest
     */
    productId?: string;
}

/**
 * 
 * @export
 * @interface V1AttachProductResponse
 */
export interface V1AttachProductResponse {
    /**
     * 
     * @type {V1Shop}
     * @memberof V1AttachProductResponse
     */
    shop?: V1Shop;
}

/**
 * 
 * @export
 * @interface V1AuthenticateRequest
 */
export interface V1AuthenticateRequest {
    /**
     * 
     * @type {string}
     * @memberof V1AuthenticateRequest
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof V1AuthenticateRequest
     */
    password?: string;
}

/**
 * 
 * @export
 * @interface V1AuthenticateResponse
 */
export interface V1AuthenticateResponse {
    /**
     * 
     * @type {string}
     * @memberof V1AuthenticateResponse
     */
    accessToken?: string;
    /**
     * 
     * @type {string}
     * @memberof V1AuthenticateResponse
     */
    tokenType?: string;
    /**
     * 
     * @type {number}
     * @memberof V1AuthenticateResponse
     */
    expiresIn?: number;
    /**
     * 
     * @type {string}
     * @memberof V1AuthenticateResponse
     */
    refreshToken?: string;
}

/**
 * 
 * @export
 * @interface V1BuyProductRequest
 */
export interface V1BuyProductRequest {
    /**
     * 
     * @type {string}
     * @memberof V1BuyProductRequest
     */
    productId?: string;
    /**
     * 
     * @type {string}
     * @memberof V1BuyProductRequest
     */
    priceId?: string;
    /**
     * 
     * @type {string}
     * @memberof V1BuyProductRequest
     */
    receivingStorageId?: string;
    /**
     * 
     * @type {string}
     * @memberof V1BuyProductRequest
     */
    payingStorageId?: string;
}

/**
 * 
 * @export
 * @interface V1BuyProductResponse
 */
export interface V1BuyProductResponse {
    /**
     * 
     * @type {V1Product}
     * @memberof V1BuyProductResponse
     */
    product?: V1Product;
}

/**
 * 
 * @export
 * @interface V1ChangePasswordRequest
 */
export interface V1ChangePasswordRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ChangePasswordRequest
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ChangePasswordRequest
     */
    password?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ChangePasswordRequest
     */
    newPassword?: string;
}

/**
 * 
 * @export
 * @interface V1ChangePasswordResponse
 */
export interface V1ChangePasswordResponse {
    /**
     * 
     * @type {string}
     * @memberof V1ChangePasswordResponse
     */
    token?: string;
}

/**
 * 
 * @export
 * @interface V1Config
 */
export interface V1Config {
    /**
     * 
     * @type {string}
     * @memberof V1Config
     */
    key?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Config
     */
    value?: string;
}

/**
 * 
 * @export
 * @interface V1CreateCurrencyRequest
 */
export interface V1CreateCurrencyRequest {
    /**
     * 
     * @type {string}
     * @memberof V1CreateCurrencyRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1CreateCurrencyRequest
     */
    shortName?: string;
    /**
     * 
     * @type {string}
     * @memberof V1CreateCurrencyRequest
     */
    symbol?: string;
}

/**
 * 
 * @export
 * @interface V1CreateCurrencyResponse
 */
export interface V1CreateCurrencyResponse {
    /**
     * 
     * @type {V1Currency}
     * @memberof V1CreateCurrencyResponse
     */
    currency?: V1Currency;
}

/**
 * 
 * @export
 * @interface V1CreateItemRequest
 */
export interface V1CreateItemRequest {
    /**
     * 
     * @type {string}
     * @memberof V1CreateItemRequest
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V1CreateItemRequest
     */
    stackable?: boolean;
    /**
     * 
     * @type {string}
     * @memberof V1CreateItemRequest
     */
    stackMaxAmount?: string;
    /**
     * 
     * @type {V1StackBalancingMethod}
     * @memberof V1CreateItemRequest
     */
    stackBalancingMethod?: V1StackBalancingMethod;
    /**
     * 
     * @type {string}
     * @memberof V1CreateItemRequest
     */
    metadata?: string;
}

/**
 * 
 * @export
 * @interface V1CreateItemResponse
 */
export interface V1CreateItemResponse {
    /**
     * 
     * @type {V1Item}
     * @memberof V1CreateItemResponse
     */
    item?: V1Item;
}

/**
 * 
 * @export
 * @interface V1CreatePlayerRequest
 */
export interface V1CreatePlayerRequest {
    /**
     * 
     * @type {string}
     * @memberof V1CreatePlayerRequest
     */
    playerId?: string;
    /**
     * 
     * @type {string}
     * @memberof V1CreatePlayerRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1CreatePlayerRequest
     */
    metadata?: string;
}

/**
 * 
 * @export
 * @interface V1CreatePlayerResponse
 */
export interface V1CreatePlayerResponse {
    /**
     * 
     * @type {V1Player}
     * @memberof V1CreatePlayerResponse
     */
    player?: V1Player;
}

/**
 * 
 * @export
 * @interface V1CreatePriceRequest
 */
export interface V1CreatePriceRequest {
    /**
     * 
     * @type {string}
     * @memberof V1CreatePriceRequest
     */
    productId?: string;
}

/**
 * 
 * @export
 * @interface V1CreatePriceResponse
 */
export interface V1CreatePriceResponse {
    /**
     * 
     * @type {V1Price}
     * @memberof V1CreatePriceResponse
     */
    price?: V1Price;
}

/**
 * 
 * @export
 * @interface V1CreateProductRequest
 */
export interface V1CreateProductRequest {
    /**
     * 
     * @type {string}
     * @memberof V1CreateProductRequest
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface V1CreateProductResponse
 */
export interface V1CreateProductResponse {
    /**
     * 
     * @type {V1Product}
     * @memberof V1CreateProductResponse
     */
    product?: V1Product;
}

/**
 * 
 * @export
 * @interface V1CreateShopRequest
 */
export interface V1CreateShopRequest {
    /**
     * 
     * @type {string}
     * @memberof V1CreateShopRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1CreateShopRequest
     */
    metadata?: string;
}

/**
 * 
 * @export
 * @interface V1CreateShopResponse
 */
export interface V1CreateShopResponse {
    /**
     * 
     * @type {V1Shop}
     * @memberof V1CreateShopResponse
     */
    shop?: V1Shop;
}

/**
 * 
 * @export
 * @interface V1CreateStorageRequest
 */
export interface V1CreateStorageRequest {
    /**
     * 
     * @type {string}
     * @memberof V1CreateStorageRequest
     */
    playerId?: string;
    /**
     * 
     * @type {string}
     * @memberof V1CreateStorageRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1CreateStorageRequest
     */
    metadata?: string;
}

/**
 * 
 * @export
 * @interface V1CreateStorageResponse
 */
export interface V1CreateStorageResponse {
    /**
     * 
     * @type {V1Storage}
     * @memberof V1CreateStorageResponse
     */
    storage?: V1Storage;
}

/**
 * 
 * @export
 * @interface V1Currency
 */
export interface V1Currency {
    /**
     * 
     * @type {string}
     * @memberof V1Currency
     */
    id?: string;
    /**
     * 
     * @type {Date}
     * @memberof V1Currency
     */
    createdAt?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1Currency
     */
    updatedAt?: Date;
    /**
     * 
     * @type {string}
     * @memberof V1Currency
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Currency
     */
    shortName?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Currency
     */
    symbol?: string;
}

/**
 * 
 * @export
 * @interface V1DeletePriceResponse
 */
export interface V1DeletePriceResponse {
    /**
     * 
     * @type {boolean}
     * @memberof V1DeletePriceResponse
     */
    success?: boolean;
}

/**
 * 
 * @export
 * @interface V1DetachCurrencyResponse
 */
export interface V1DetachCurrencyResponse {
    /**
     * 
     * @type {V1Product}
     * @memberof V1DetachCurrencyResponse
     */
    product?: V1Product;
}

/**
 * 
 * @export
 * @interface V1DetachItemResponse
 */
export interface V1DetachItemResponse {
    /**
     * 
     * @type {V1Product}
     * @memberof V1DetachItemResponse
     */
    product?: V1Product;
}

/**
 * 
 * @export
 * @interface V1DetachPriceCurrencyResponse
 */
export interface V1DetachPriceCurrencyResponse {
    /**
     * 
     * @type {V1Price}
     * @memberof V1DetachPriceCurrencyResponse
     */
    price?: V1Price;
}

/**
 * 
 * @export
 * @interface V1DetachPriceItemResponse
 */
export interface V1DetachPriceItemResponse {
    /**
     * 
     * @type {V1Price}
     * @memberof V1DetachPriceItemResponse
     */
    price?: V1Price;
}

/**
 * 
 * @export
 * @interface V1DetachProductResponse
 */
export interface V1DetachProductResponse {
    /**
     * 
     * @type {V1Shop}
     * @memberof V1DetachProductResponse
     */
    shop?: V1Shop;
}

/**
 * 
 * @export
 * @interface V1GenerateSecretRequest
 */
export interface V1GenerateSecretRequest {
    /**
     * 
     * @type {string}
     * @memberof V1GenerateSecretRequest
     */
    accountId?: string;
}

/**
 * 
 * @export
 * @interface V1GenerateSecretResponse
 */
export interface V1GenerateSecretResponse {
    /**
     * 
     * @type {string}
     * @memberof V1GenerateSecretResponse
     */
    token?: string;
}

/**
 * 
 * @export
 * @interface V1GetAccountResponse
 */
export interface V1GetAccountResponse {
    /**
     * 
     * @type {V1Account}
     * @memberof V1GetAccountResponse
     */
    account?: V1Account;
}

/**
 * 
 * @export
 * @interface V1GetConfigResponse
 */
export interface V1GetConfigResponse {
    /**
     * 
     * @type {V1Config}
     * @memberof V1GetConfigResponse
     */
    config?: V1Config;
}

/**
 * 
 * @export
 * @interface V1GetCurrencyResponse
 */
export interface V1GetCurrencyResponse {
    /**
     * 
     * @type {V1Currency}
     * @memberof V1GetCurrencyResponse
     */
    currency?: V1Currency;
}

/**
 * 
 * @export
 * @interface V1GetItemResponse
 */
export interface V1GetItemResponse {
    /**
     * 
     * @type {V1Item}
     * @memberof V1GetItemResponse
     */
    item?: V1Item;
}

/**
 * 
 * @export
 * @interface V1GetPlayerResponse
 */
export interface V1GetPlayerResponse {
    /**
     * 
     * @type {V1Player}
     * @memberof V1GetPlayerResponse
     */
    player?: V1Player;
}

/**
 * 
 * @export
 * @interface V1GetPriceResponse
 */
export interface V1GetPriceResponse {
    /**
     * 
     * @type {V1Price}
     * @memberof V1GetPriceResponse
     */
    price?: V1Price;
}

/**
 * 
 * @export
 * @interface V1GetProductResponse
 */
export interface V1GetProductResponse {
    /**
     * 
     * @type {V1Product}
     * @memberof V1GetProductResponse
     */
    product?: V1Product;
}

/**
 * 
 * @export
 * @interface V1GetShopResponse
 */
export interface V1GetShopResponse {
    /**
     * 
     * @type {V1Shop}
     * @memberof V1GetShopResponse
     */
    shop?: V1Shop;
}

/**
 * 
 * @export
 * @interface V1GetStorageResponse
 */
export interface V1GetStorageResponse {
    /**
     * 
     * @type {V1Storage}
     * @memberof V1GetStorageResponse
     */
    storage?: V1Storage;
}

/**
 * 
 * @export
 * @interface V1GiveCurrencyRequest
 */
export interface V1GiveCurrencyRequest {
    /**
     * 
     * @type {string}
     * @memberof V1GiveCurrencyRequest
     */
    storageId?: string;
    /**
     * 
     * @type {string}
     * @memberof V1GiveCurrencyRequest
     */
    currencyId?: string;
    /**
     * 
     * @type {V1Amount}
     * @memberof V1GiveCurrencyRequest
     */
    amount?: V1Amount;
}

/**
 * 
 * @export
 * @interface V1GiveCurrencyResponse
 */
export interface V1GiveCurrencyResponse {
    /**
     * 
     * @type {V1StorageCurrency}
     * @memberof V1GiveCurrencyResponse
     */
    currency?: V1StorageCurrency;
}

/**
 * 
 * @export
 * @interface V1GiveItemRequest
 */
export interface V1GiveItemRequest {
    /**
     * 
     * @type {string}
     * @memberof V1GiveItemRequest
     */
    storageId?: string;
    /**
     * 
     * @type {string}
     * @memberof V1GiveItemRequest
     */
    itemId?: string;
    /**
     * 
     * @type {V1Amount}
     * @memberof V1GiveItemRequest
     */
    amount?: V1Amount;
}

/**
 * 
 * @export
 * @interface V1GiveItemResponse
 */
export interface V1GiveItemResponse {
    /**
     * 
     * @type {string}
     * @memberof V1GiveItemResponse
     */
    storageId?: string;
    /**
     * 
     * @type {string}
     * @memberof V1GiveItemResponse
     */
    amount?: string;
}

/**
 * 
 * @export
 * @interface V1Item
 */
export interface V1Item {
    /**
     * 
     * @type {string}
     * @memberof V1Item
     */
    id?: string;
    /**
     * 
     * @type {Date}
     * @memberof V1Item
     */
    createdAt?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1Item
     */
    updatedAt?: Date;
    /**
     * 
     * @type {string}
     * @memberof V1Item
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V1Item
     */
    stackable?: boolean;
    /**
     * 
     * @type {string}
     * @memberof V1Item
     */
    stackMaxAmount?: string;
    /**
     * 
     * @type {V1StackBalancingMethod}
     * @memberof V1Item
     */
    stackBalancingMethod?: V1StackBalancingMethod;
    /**
     * 
     * @type {string}
     * @memberof V1Item
     */
    metadata?: string;
}

/**
 * 
 * @export
 * @interface V1ListAccountResponse
 */
export interface V1ListAccountResponse {
    /**
     * 
     * @type {Array<V1Account>}
     * @memberof V1ListAccountResponse
     */
    accounts?: Array<V1Account>;
    /**
     * 
     * @type {string}
     * @memberof V1ListAccountResponse
     */
    nextPageToken?: string;
    /**
     * 
     * @type {number}
     * @memberof V1ListAccountResponse
     */
    totalSize?: number;
}

/**
 * 
 * @export
 * @interface V1ListConfigResponse
 */
export interface V1ListConfigResponse {
    /**
     * 
     * @type {Array<V1Config>}
     * @memberof V1ListConfigResponse
     */
    configs?: Array<V1Config>;
    /**
     * 
     * @type {string}
     * @memberof V1ListConfigResponse
     */
    nextPageToken?: string;
    /**
     * 
     * @type {number}
     * @memberof V1ListConfigResponse
     */
    totalSize?: number;
}

/**
 * 
 * @export
 * @interface V1ListCurrencyResponse
 */
export interface V1ListCurrencyResponse {
    /**
     * 
     * @type {Array<V1Currency>}
     * @memberof V1ListCurrencyResponse
     */
    currencies?: Array<V1Currency>;
    /**
     * 
     * @type {string}
     * @memberof V1ListCurrencyResponse
     */
    nextPageToken?: string;
    /**
     * 
     * @type {number}
     * @memberof V1ListCurrencyResponse
     */
    totalSize?: number;
}

/**
 * 
 * @export
 * @interface V1ListItemResponse
 */
export interface V1ListItemResponse {
    /**
     * 
     * @type {Array<V1Item>}
     * @memberof V1ListItemResponse
     */
    items?: Array<V1Item>;
    /**
     * 
     * @type {string}
     * @memberof V1ListItemResponse
     */
    nextPageToken?: string;
    /**
     * 
     * @type {number}
     * @memberof V1ListItemResponse
     */
    totalSize?: number;
}

/**
 * 
 * @export
 * @interface V1ListPlayerResponse
 */
export interface V1ListPlayerResponse {
    /**
     * 
     * @type {Array<V1Player>}
     * @memberof V1ListPlayerResponse
     */
    players?: Array<V1Player>;
    /**
     * 
     * @type {string}
     * @memberof V1ListPlayerResponse
     */
    nextPageToken?: string;
    /**
     * 
     * @type {number}
     * @memberof V1ListPlayerResponse
     */
    totalSize?: number;
}

/**
 * 
 * @export
 * @interface V1ListProductPriceResponse
 */
export interface V1ListProductPriceResponse {
    /**
     * 
     * @type {Array<V1Price>}
     * @memberof V1ListProductPriceResponse
     */
    prices?: Array<V1Price>;
}

/**
 * 
 * @export
 * @interface V1ListProductResponse
 */
export interface V1ListProductResponse {
    /**
     * 
     * @type {Array<V1Product>}
     * @memberof V1ListProductResponse
     */
    products?: Array<V1Product>;
    /**
     * 
     * @type {string}
     * @memberof V1ListProductResponse
     */
    nextPageToken?: string;
    /**
     * 
     * @type {number}
     * @memberof V1ListProductResponse
     */
    totalSize?: number;
}

/**
 * 
 * @export
 * @interface V1ListShopResponse
 */
export interface V1ListShopResponse {
    /**
     * 
     * @type {Array<V1Shop>}
     * @memberof V1ListShopResponse
     */
    shops?: Array<V1Shop>;
    /**
     * 
     * @type {string}
     * @memberof V1ListShopResponse
     */
    nextPageToken?: string;
    /**
     * 
     * @type {number}
     * @memberof V1ListShopResponse
     */
    totalSize?: number;
}

/**
 * 
 * @export
 * @interface V1ListStorageResponse
 */
export interface V1ListStorageResponse {
    /**
     * 
     * @type {Array<V1Storage>}
     * @memberof V1ListStorageResponse
     */
    storages?: Array<V1Storage>;
    /**
     * 
     * @type {string}
     * @memberof V1ListStorageResponse
     */
    nextPageToken?: string;
    /**
     * 
     * @type {number}
     * @memberof V1ListStorageResponse
     */
    totalSize?: number;
}

/**
 * 
 * @export
 * @interface V1MergeStackRequest
 */
export interface V1MergeStackRequest {
    /**
     * 
     * @type {string}
     * @memberof V1MergeStackRequest
     */
    toStorageId?: string;
    /**
     * 
     * @type {string}
     * @memberof V1MergeStackRequest
     */
    toStorageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof V1MergeStackRequest
     */
    fromStorageId?: string;
    /**
     * 
     * @type {string}
     * @memberof V1MergeStackRequest
     */
    fromStorageItemId?: string;
}

/**
 * 
 * @export
 * @interface V1MergeStackResponse
 */
export interface V1MergeStackResponse {
    /**
     * 
     * @type {V1Storage}
     * @memberof V1MergeStackResponse
     */
    storage?: V1Storage;
}

/**
 * 
 * @export
 * @interface V1Player
 */
export interface V1Player {
    /**
     * 
     * @type {string}
     * @memberof V1Player
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Player
     */
    name?: string;
    /**
     * 
     * @type {Array<V1Storage>}
     * @memberof V1Player
     */
    storages?: Array<V1Storage>;
    /**
     * 
     * @type {string}
     * @memberof V1Player
     */
    metadata?: string;
}

/**
 * 
 * @export
 * @interface V1Price
 */
export interface V1Price {
    /**
     * 
     * @type {string}
     * @memberof V1Price
     */
    id?: string;
    /**
     * 
     * @type {Date}
     * @memberof V1Price
     */
    createdAt?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1Price
     */
    updatedAt?: Date;
    /**
     * 
     * @type {Array<V1PriceCurrency>}
     * @memberof V1Price
     */
    currencies?: Array<V1PriceCurrency>;
    /**
     * 
     * @type {Array<V1PriceItem>}
     * @memberof V1Price
     */
    items?: Array<V1PriceItem>;
}

/**
 * 
 * @export
 * @interface V1PriceCurrency
 */
export interface V1PriceCurrency {
    /**
     * 
     * @type {string}
     * @memberof V1PriceCurrency
     */
    id?: string;
    /**
     * 
     * @type {V1Currency}
     * @memberof V1PriceCurrency
     */
    currency?: V1Currency;
    /**
     * 
     * @type {string}
     * @memberof V1PriceCurrency
     */
    amount?: string;
}

/**
 * 
 * @export
 * @interface V1PriceItem
 */
export interface V1PriceItem {
    /**
     * 
     * @type {string}
     * @memberof V1PriceItem
     */
    id?: string;
    /**
     * 
     * @type {V1Item}
     * @memberof V1PriceItem
     */
    item?: V1Item;
    /**
     * 
     * @type {string}
     * @memberof V1PriceItem
     */
    amount?: string;
}

/**
 * 
 * @export
 * @interface V1Product
 */
export interface V1Product {
    /**
     * 
     * @type {string}
     * @memberof V1Product
     */
    id?: string;
    /**
     * 
     * @type {Date}
     * @memberof V1Product
     */
    createdAt?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1Product
     */
    updatedAt?: Date;
    /**
     * 
     * @type {string}
     * @memberof V1Product
     */
    name?: string;
    /**
     * 
     * @type {Array<V1ProductItem>}
     * @memberof V1Product
     */
    items?: Array<V1ProductItem>;
    /**
     * 
     * @type {Array<V1ProductCurrency>}
     * @memberof V1Product
     */
    currencies?: Array<V1ProductCurrency>;
    /**
     * 
     * @type {Array<V1Price>}
     * @memberof V1Product
     */
    prices?: Array<V1Price>;
    /**
     * 
     * @type {string}
     * @memberof V1Product
     */
    metadata?: string;
}

/**
 * 
 * @export
 * @interface V1ProductCurrency
 */
export interface V1ProductCurrency {
    /**
     * 
     * @type {string}
     * @memberof V1ProductCurrency
     */
    id?: string;
    /**
     * 
     * @type {V1Currency}
     * @memberof V1ProductCurrency
     */
    currency?: V1Currency;
    /**
     * 
     * @type {string}
     * @memberof V1ProductCurrency
     */
    amount?: string;
}

/**
 * 
 * @export
 * @interface V1ProductItem
 */
export interface V1ProductItem {
    /**
     * 
     * @type {string}
     * @memberof V1ProductItem
     */
    id?: string;
    /**
     * 
     * @type {V1Item}
     * @memberof V1ProductItem
     */
    item?: V1Item;
    /**
     * 
     * @type {string}
     * @memberof V1ProductItem
     */
    amount?: string;
}

/**
 * 
 * @export
 * @interface V1RefreshRequest
 */
export interface V1RefreshRequest {
    /**
     * 
     * @type {string}
     * @memberof V1RefreshRequest
     */
    token?: string;
}

/**
 * 
 * @export
 * @interface V1RefreshResponse
 */
export interface V1RefreshResponse {
    /**
     * 
     * @type {string}
     * @memberof V1RefreshResponse
     */
    accessToken?: string;
    /**
     * 
     * @type {string}
     * @memberof V1RefreshResponse
     */
    tokenType?: string;
    /**
     * 
     * @type {number}
     * @memberof V1RefreshResponse
     */
    expiresIn?: number;
}

/**
 * 
 * @export
 * @interface V1RegisterRequest
 */
export interface V1RegisterRequest {
    /**
     * 
     * @type {string}
     * @memberof V1RegisterRequest
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof V1RegisterRequest
     */
    password?: string;
}

/**
 * 
 * @export
 * @interface V1RegisterResponse
 */
export interface V1RegisterResponse {
    /**
     * 
     * @type {string}
     * @memberof V1RegisterResponse
     */
    token?: string;
}

/**
 * 
 * @export
 * @interface V1RevokePermissionRequest
 */
export interface V1RevokePermissionRequest {
    /**
     * 
     * @type {string}
     * @memberof V1RevokePermissionRequest
     */
    accountId?: string;
    /**
     * 
     * @type {string}
     * @memberof V1RevokePermissionRequest
     */
    permission?: string;
}

/**
 * 
 * @export
 * @interface V1RevokePermissionResponse
 */
export interface V1RevokePermissionResponse {
    /**
     * 
     * @type {V1Account}
     * @memberof V1RevokePermissionResponse
     */
    account?: V1Account;
}

/**
 * 
 * @export
 * @interface V1SearchItemRequest
 */
export interface V1SearchItemRequest {
    /**
     * 
     * @type {string}
     * @memberof V1SearchItemRequest
     */
    query?: string;
    /**
     * 
     * @type {number}
     * @memberof V1SearchItemRequest
     */
    pageSize?: number;
    /**
     * 
     * @type {string}
     * @memberof V1SearchItemRequest
     */
    pageToken?: string;
}

/**
 * 
 * @export
 * @interface V1SearchItemResponse
 */
export interface V1SearchItemResponse {
    /**
     * 
     * @type {Array<V1Item>}
     * @memberof V1SearchItemResponse
     */
    items?: Array<V1Item>;
    /**
     * 
     * @type {string}
     * @memberof V1SearchItemResponse
     */
    nextPageToken?: string;
    /**
     * 
     * @type {number}
     * @memberof V1SearchItemResponse
     */
    totalSize?: number;
}

/**
 * 
 * @export
 * @interface V1SearchPlayerRequest
 */
export interface V1SearchPlayerRequest {
    /**
     * 
     * @type {string}
     * @memberof V1SearchPlayerRequest
     */
    query?: string;
    /**
     * 
     * @type {number}
     * @memberof V1SearchPlayerRequest
     */
    pageSize?: number;
    /**
     * 
     * @type {string}
     * @memberof V1SearchPlayerRequest
     */
    pageToken?: string;
}

/**
 * 
 * @export
 * @interface V1SearchPlayerResponse
 */
export interface V1SearchPlayerResponse {
    /**
     * 
     * @type {Array<V1Player>}
     * @memberof V1SearchPlayerResponse
     */
    players?: Array<V1Player>;
    /**
     * 
     * @type {string}
     * @memberof V1SearchPlayerResponse
     */
    nextPageToken?: string;
    /**
     * 
     * @type {number}
     * @memberof V1SearchPlayerResponse
     */
    totalSize?: number;
}

/**
 * 
 * @export
 * @interface V1SetConfigRequest
 */
export interface V1SetConfigRequest {
    /**
     * 
     * @type {string}
     * @memberof V1SetConfigRequest
     */
    key?: string;
    /**
     * 
     * @type {string}
     * @memberof V1SetConfigRequest
     */
    value?: string;
}

/**
 * 
 * @export
 * @interface V1SetConfigResponse
 */
export interface V1SetConfigResponse {
    /**
     * 
     * @type {V1Config}
     * @memberof V1SetConfigResponse
     */
    config?: V1Config;
}

/**
 * 
 * @export
 * @interface V1Shop
 */
export interface V1Shop {
    /**
     * 
     * @type {string}
     * @memberof V1Shop
     */
    id?: string;
    /**
     * 
     * @type {Date}
     * @memberof V1Shop
     */
    createdAt?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1Shop
     */
    updatedAt?: Date;
    /**
     * 
     * @type {string}
     * @memberof V1Shop
     */
    name?: string;
    /**
     * 
     * @type {Array<V1Product>}
     * @memberof V1Shop
     */
    products?: Array<V1Product>;
    /**
     * 
     * @type {string}
     * @memberof V1Shop
     */
    metadata?: string;
}

/**
 * 
 * @export
 * @interface V1SplitStackRequest
 */
export interface V1SplitStackRequest {
    /**
     * 
     * @type {string}
     * @memberof V1SplitStackRequest
     */
    storageId?: string;
    /**
     * 
     * @type {string}
     * @memberof V1SplitStackRequest
     */
    storageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof V1SplitStackRequest
     */
    chunks?: string;
    /**
     * 
     * @type {string}
     * @memberof V1SplitStackRequest
     */
    amount?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1SplitStackRequest
     */
    amounts?: Array<string>;
}

/**
 * 
 * @export
 * @interface V1SplitStackResponse
 */
export interface V1SplitStackResponse {
    /**
     * 
     * @type {V1Storage}
     * @memberof V1SplitStackResponse
     */
    storage?: V1Storage;
}

/**
 * - DEFAULT: Same as the UNBALANCED_CREATE_NEW_STACKS method  - UNBALANCED_CREATE_NEW_STACKS: Multiple stacks exists and can have varying amounts of items in them. Whenever new items are added it will create new stacks  - BALANCED_FILL_EXISTING_STACKS: There can be only 1 stack that's not the stack_max_amountj, if there are 2 stack's with less than the stack_max_amount one stack will be reduced till the other fill up till the stack_max_amount. Whenever new items are added it will try to fill up existing stacks till the stack_max_amount.  - UNBALANCED_FILL_EXISTING_STACKS: Multiple stacks exists and can have varying amounts of items in them. Whenever new items are added it will try to fill up existing stacks till the stack_max_amount.
 * @export
 * @enum {string}
 */
export enum V1StackBalancingMethod {
    DEFAULT = <any> 'DEFAULT',
    UNBALANCEDCREATENEWSTACKS = <any> 'UNBALANCED_CREATE_NEW_STACKS',
    BALANCEDFILLEXISTINGSTACKS = <any> 'BALANCED_FILL_EXISTING_STACKS',
    UNBALANCEDFILLEXISTINGSTACKS = <any> 'UNBALANCED_FILL_EXISTING_STACKS'
}

/**
 * 
 * @export
 * @interface V1Storage
 */
export interface V1Storage {
    /**
     * 
     * @type {string}
     * @memberof V1Storage
     */
    id?: string;
    /**
     * 
     * @type {Date}
     * @memberof V1Storage
     */
    createdAt?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1Storage
     */
    updatedAt?: Date;
    /**
     * 
     * @type {string}
     * @memberof V1Storage
     */
    playerId?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Storage
     */
    name?: string;
    /**
     * 
     * @type {Array<V1StorageItem>}
     * @memberof V1Storage
     */
    items?: Array<V1StorageItem>;
    /**
     * 
     * @type {Array<V1StorageCurrency>}
     * @memberof V1Storage
     */
    currencies?: Array<V1StorageCurrency>;
    /**
     * 
     * @type {string}
     * @memberof V1Storage
     */
    metadata?: string;
}

/**
 * 
 * @export
 * @interface V1StorageCurrency
 */
export interface V1StorageCurrency {
    /**
     * 
     * @type {string}
     * @memberof V1StorageCurrency
     */
    id?: string;
    /**
     * 
     * @type {V1Currency}
     * @memberof V1StorageCurrency
     */
    currency?: V1Currency;
    /**
     * 
     * @type {string}
     * @memberof V1StorageCurrency
     */
    amount?: string;
}

/**
 * 
 * @export
 * @interface V1StorageItem
 */
export interface V1StorageItem {
    /**
     * 
     * @type {string}
     * @memberof V1StorageItem
     */
    id?: string;
    /**
     * 
     * @type {Date}
     * @memberof V1StorageItem
     */
    createdAt?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1StorageItem
     */
    updatedAt?: Date;
    /**
     * 
     * @type {V1Item}
     * @memberof V1StorageItem
     */
    item?: V1Item;
    /**
     * 
     * @type {string}
     * @memberof V1StorageItem
     */
    amount?: string;
}

/**
 * 
 * @export
 * @interface V1UpdateCurrencyRequest
 */
export interface V1UpdateCurrencyRequest {
    /**
     * 
     * @type {string}
     * @memberof V1UpdateCurrencyRequest
     */
    currencyId?: string;
    /**
     * 
     * @type {string}
     * @memberof V1UpdateCurrencyRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1UpdateCurrencyRequest
     */
    shortName?: string;
    /**
     * 
     * @type {string}
     * @memberof V1UpdateCurrencyRequest
     */
    symbol?: string;
}

/**
 * 
 * @export
 * @interface V1UpdateCurrencyResponse
 */
export interface V1UpdateCurrencyResponse {
    /**
     * 
     * @type {V1Currency}
     * @memberof V1UpdateCurrencyResponse
     */
    currency?: V1Currency;
}

/**
 * 
 * @export
 * @interface V1UpdateItemRequest
 */
export interface V1UpdateItemRequest {
    /**
     * 
     * @type {string}
     * @memberof V1UpdateItemRequest
     */
    itemId?: string;
    /**
     * 
     * @type {string}
     * @memberof V1UpdateItemRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1UpdateItemRequest
     */
    metadata?: string;
}

/**
 * 
 * @export
 * @interface V1UpdateItemResponse
 */
export interface V1UpdateItemResponse {
    /**
     * 
     * @type {V1Item}
     * @memberof V1UpdateItemResponse
     */
    item?: V1Item;
}

/**
 * 
 * @export
 * @interface V1UpdatePlayerRequest
 */
export interface V1UpdatePlayerRequest {
    /**
     * 
     * @type {string}
     * @memberof V1UpdatePlayerRequest
     */
    playerId?: string;
    /**
     * 
     * @type {string}
     * @memberof V1UpdatePlayerRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1UpdatePlayerRequest
     */
    metadata?: string;
}

/**
 * 
 * @export
 * @interface V1UpdatePlayerResponse
 */
export interface V1UpdatePlayerResponse {
    /**
     * 
     * @type {V1Player}
     * @memberof V1UpdatePlayerResponse
     */
    player?: V1Player;
}

/**
 * 
 * @export
 * @interface V1UpdateProductRequest
 */
export interface V1UpdateProductRequest {
    /**
     * 
     * @type {string}
     * @memberof V1UpdateProductRequest
     */
    productId?: string;
    /**
     * 
     * @type {string}
     * @memberof V1UpdateProductRequest
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface V1UpdateProductResponse
 */
export interface V1UpdateProductResponse {
    /**
     * 
     * @type {V1Product}
     * @memberof V1UpdateProductResponse
     */
    product?: V1Product;
}

/**
 * 
 * @export
 * @interface V1UpdateShopRequest
 */
export interface V1UpdateShopRequest {
    /**
     * 
     * @type {string}
     * @memberof V1UpdateShopRequest
     */
    shopId?: string;
    /**
     * 
     * @type {string}
     * @memberof V1UpdateShopRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1UpdateShopRequest
     */
    metadata?: string;
}

/**
 * 
 * @export
 * @interface V1UpdateShopResponse
 */
export interface V1UpdateShopResponse {
    /**
     * 
     * @type {V1Shop}
     * @memberof V1UpdateShopResponse
     */
    shop?: V1Shop;
}

/**
 * 
 * @export
 * @interface V1UpdateStorageRequest
 */
export interface V1UpdateStorageRequest {
    /**
     * 
     * @type {string}
     * @memberof V1UpdateStorageRequest
     */
    storageId?: string;
    /**
     * 
     * @type {string}
     * @memberof V1UpdateStorageRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1UpdateStorageRequest
     */
    metadata?: string;
}

/**
 * 
 * @export
 * @interface V1UpdateStorageResponse
 */
export interface V1UpdateStorageResponse {
    /**
     * 
     * @type {V1Storage}
     * @memberof V1UpdateStorageResponse
     */
    storage?: V1Storage;
}


/**
 * EconomyServiceApi - fetch parameter creator
 * @export
 */
export const EconomyServiceApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Assigns a permission
         * @param {V1AssignPermissionRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignPermission(body: V1AssignPermissionRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling assignPermission.');
            }
            const localVarPath = `/v1/account/permission/assign`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1AssignPermissionRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Attach currency to a product
         * @param {V1AttachCurrencyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachCurrency(body: V1AttachCurrencyRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling attachCurrency.');
            }
            const localVarPath = `/v1/product/attach/currency`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1AttachCurrencyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Attach item to a product
         * @param {V1AttachItemRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachItem(body: V1AttachItemRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling attachItem.');
            }
            const localVarPath = `/v1/product/attach/item`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1AttachItemRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Attach currency to a Price
         * @param {V1AttachPriceCurrencyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachPriceCurrency(body: V1AttachPriceCurrencyRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling attachPriceCurrency.');
            }
            const localVarPath = `/v1/price/attach/currency`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1AttachPriceCurrencyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Attach item to a Price
         * @param {V1AttachPriceItemRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachPriceItem(body: V1AttachPriceItemRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling attachPriceItem.');
            }
            const localVarPath = `/v1/price/attach/item`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1AttachPriceItemRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Attach product to a shop
         * @param {V1AttachProductRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachProduct(body: V1AttachProductRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling attachProduct.');
            }
            const localVarPath = `/v1/shop/attach/product`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1AttachProductRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Authenticate an account
         * @param {V1AuthenticateRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticate(body: V1AuthenticateRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling authenticate.');
            }
            const localVarPath = `/v1/authenticate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1AuthenticateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Buy product from the store
         * @param {V1BuyProductRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buyProduct(body: V1BuyProductRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling buyProduct.');
            }
            const localVarPath = `/v1/product/buy`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1BuyProductRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Change password
         * @param {V1ChangePasswordRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword(body: V1ChangePasswordRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling changePassword.');
            }
            const localVarPath = `/v1/account/password`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1ChangePasswordRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a currency
         * @param {V1CreateCurrencyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCurrency(body: V1CreateCurrencyRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createCurrency.');
            }
            const localVarPath = `/v1/currency`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1CreateCurrencyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create an Item
         * @param {V1CreateItemRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItem(body: V1CreateItemRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createItem.');
            }
            const localVarPath = `/v1/item`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1CreateItemRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a player
         * @param {V1CreatePlayerRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPlayer(body: V1CreatePlayerRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createPlayer.');
            }
            const localVarPath = `/v1/player`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1CreatePlayerRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a price
         * @param {V1CreatePriceRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPrice(body: V1CreatePriceRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createPrice.');
            }
            const localVarPath = `/v1/price`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1CreatePriceRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a product
         * @param {V1CreateProductRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProduct(body: V1CreateProductRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createProduct.');
            }
            const localVarPath = `/v1/product`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1CreateProductRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a shop
         * @param {V1CreateShopRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createShop(body: V1CreateShopRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createShop.');
            }
            const localVarPath = `/v1/shop`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1CreateShopRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new Storage
         * @param {V1CreateStorageRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStorage(body: V1CreateStorageRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createStorage.');
            }
            const localVarPath = `/v1/storage`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1CreateStorageRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a price
         * @param {string} priceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePrice(priceId: string, options: any = {}): FetchArgs {
            // verify required parameter 'priceId' is not null or undefined
            if (priceId === null || priceId === undefined) {
                throw new RequiredError('priceId','Required parameter priceId was null or undefined when calling deletePrice.');
            }
            const localVarPath = `/v1/price/{price_id}`
                .replace(`{${"price_id"}}`, encodeURIComponent(String(priceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Detach currency from a product
         * @param {string} productCurrencyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detachCurrency(productCurrencyId: string, options: any = {}): FetchArgs {
            // verify required parameter 'productCurrencyId' is not null or undefined
            if (productCurrencyId === null || productCurrencyId === undefined) {
                throw new RequiredError('productCurrencyId','Required parameter productCurrencyId was null or undefined when calling detachCurrency.');
            }
            const localVarPath = `/v1/product/detach/currency/{product_currency_id}`
                .replace(`{${"product_currency_id"}}`, encodeURIComponent(String(productCurrencyId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Detach item from a product
         * @param {string} productItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detachItem(productItemId: string, options: any = {}): FetchArgs {
            // verify required parameter 'productItemId' is not null or undefined
            if (productItemId === null || productItemId === undefined) {
                throw new RequiredError('productItemId','Required parameter productItemId was null or undefined when calling detachItem.');
            }
            const localVarPath = `/v1/product/detach/item/{product_item_id}`
                .replace(`{${"product_item_id"}}`, encodeURIComponent(String(productItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Detach currency from a Price
         * @param {string} priceCurrencyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detachPriceCurrency(priceCurrencyId: string, options: any = {}): FetchArgs {
            // verify required parameter 'priceCurrencyId' is not null or undefined
            if (priceCurrencyId === null || priceCurrencyId === undefined) {
                throw new RequiredError('priceCurrencyId','Required parameter priceCurrencyId was null or undefined when calling detachPriceCurrency.');
            }
            const localVarPath = `/v1/price/detach/currency/{price_currency_id}`
                .replace(`{${"price_currency_id"}}`, encodeURIComponent(String(priceCurrencyId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Detach item to a Price
         * @param {string} priceItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detachPriceItem(priceItemId: string, options: any = {}): FetchArgs {
            // verify required parameter 'priceItemId' is not null or undefined
            if (priceItemId === null || priceItemId === undefined) {
                throw new RequiredError('priceItemId','Required parameter priceItemId was null or undefined when calling detachPriceItem.');
            }
            const localVarPath = `/v1/price/detach/item/{price_item_id}`
                .replace(`{${"price_item_id"}}`, encodeURIComponent(String(priceItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Detach product from a shop
         * @param {string} shopProductId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detachProduct(shopProductId: string, options: any = {}): FetchArgs {
            // verify required parameter 'shopProductId' is not null or undefined
            if (shopProductId === null || shopProductId === undefined) {
                throw new RequiredError('shopProductId','Required parameter shopProductId was null or undefined when calling detachProduct.');
            }
            const localVarPath = `/v1/shop/detach/product/{shop_product_id}`
                .replace(`{${"shop_product_id"}}`, encodeURIComponent(String(shopProductId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary GenerateSecret a long lived JWT
         * @param {V1GenerateSecretRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateSecret(body: V1GenerateSecretRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling generateSecret.');
            }
            const localVarPath = `/v1/secret`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1GenerateSecretRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get an accounts
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount(accountId: string, options: any = {}): FetchArgs {
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling getAccount.');
            }
            const localVarPath = `/v1/account/{account_id}`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a config
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfig(key: string, options: any = {}): FetchArgs {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling getConfig.');
            }
            const localVarPath = `/v1/config/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a currency
         * @param {string} currencyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrency(currencyId: string, options: any = {}): FetchArgs {
            // verify required parameter 'currencyId' is not null or undefined
            if (currencyId === null || currencyId === undefined) {
                throw new RequiredError('currencyId','Required parameter currencyId was null or undefined when calling getCurrency.');
            }
            const localVarPath = `/v1/currency/{currency_id}`
                .replace(`{${"currency_id"}}`, encodeURIComponent(String(currencyId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get an Item
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItem(itemId: string, options: any = {}): FetchArgs {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getItem.');
            }
            const localVarPath = `/v1/item/{item_id}`
                .replace(`{${"item_id"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To see what Storages belong to an User
         * @param {string} playerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayer(playerId: string, options: any = {}): FetchArgs {
            // verify required parameter 'playerId' is not null or undefined
            if (playerId === null || playerId === undefined) {
                throw new RequiredError('playerId','Required parameter playerId was null or undefined when calling getPlayer.');
            }
            const localVarPath = `/v1/player/{player_id}`
                .replace(`{${"player_id"}}`, encodeURIComponent(String(playerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a Price
         * @param {string} priceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPrice(priceId: string, options: any = {}): FetchArgs {
            // verify required parameter 'priceId' is not null or undefined
            if (priceId === null || priceId === undefined) {
                throw new RequiredError('priceId','Required parameter priceId was null or undefined when calling getPrice.');
            }
            const localVarPath = `/v1/price/{price_id}`
                .replace(`{${"price_id"}}`, encodeURIComponent(String(priceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a product
         * @param {string} productId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProduct(productId: string, options: any = {}): FetchArgs {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling getProduct.');
            }
            const localVarPath = `/v1/product/{product_id}`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a shop
         * @param {string} shopId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShop(shopId: string, options: any = {}): FetchArgs {
            // verify required parameter 'shopId' is not null or undefined
            if (shopId === null || shopId === undefined) {
                throw new RequiredError('shopId','Required parameter shopId was null or undefined when calling getShop.');
            }
            const localVarPath = `/v1/shop/{shop_id}`
                .replace(`{${"shop_id"}}`, encodeURIComponent(String(shopId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the contents of a storage
         * @param {string} storageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorage(storageId: string, options: any = {}): FetchArgs {
            // verify required parameter 'storageId' is not null or undefined
            if (storageId === null || storageId === undefined) {
                throw new RequiredError('storageId','Required parameter storageId was null or undefined when calling getStorage.');
            }
            const localVarPath = `/v1/storage/{storage_id}`
                .replace(`{${"storage_id"}}`, encodeURIComponent(String(storageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Give an amount of Currency to a Storage
         * @param {V1GiveCurrencyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giveCurrency(body: V1GiveCurrencyRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling giveCurrency.');
            }
            const localVarPath = `/v1/storage/give/currency`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1GiveCurrencyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Give Item to a Storage
         * @param {V1GiveItemRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giveItem(body: V1GiveItemRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling giveItem.');
            }
            const localVarPath = `/v1/storage/give/item`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1GiveItemRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all accounts
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccount(pageSize?: number, pageToken?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v1/account`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = pageToken;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all configs
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConfig(pageSize?: number, pageToken?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v1/config`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = pageToken;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Shows all currencies
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCurrency(pageSize?: number, pageToken?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v1/currency`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = pageToken;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all Items
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listItem(pageSize?: number, pageToken?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v1/item`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = pageToken;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all players
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPlayer(pageSize?: number, pageToken?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v1/player`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = pageToken;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all product
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProduct(pageSize?: number, pageToken?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v1/product`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = pageToken;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a price
         * @param {string} productId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProductPrice(productId: string, options: any = {}): FetchArgs {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling listProductPrice.');
            }
            const localVarPath = `/v1/product/{product_id}/price`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all shops
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listShop(pageSize?: number, pageToken?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v1/shop`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = pageToken;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all storages
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listStorage(pageSize?: number, pageToken?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v1/storage`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = pageToken;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Merge stack
         * @param {V1MergeStackRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeStack(body: V1MergeStackRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling mergeStack.');
            }
            const localVarPath = `/v1/storage/merge/stack`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1MergeStackRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Refresh a token
         * @param {V1RefreshRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refresh(body: V1RefreshRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling refresh.');
            }
            const localVarPath = `/v1/refresh`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1RefreshRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register an account
         * @param {V1RegisterRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(body: V1RegisterRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling register.');
            }
            const localVarPath = `/v1/register`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1RegisterRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Revokes a permission
         * @param {V1RevokePermissionRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokePermission(body: V1RevokePermissionRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling revokePermission.');
            }
            const localVarPath = `/v1/account/permission/revoke`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1RevokePermissionRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search item
         * @param {V1SearchItemRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchItem(body: V1SearchItemRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling searchItem.');
            }
            const localVarPath = `/v1/item/search`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1SearchItemRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search player
         * @param {V1SearchPlayerRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPlayer(body: V1SearchPlayerRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling searchPlayer.');
            }
            const localVarPath = `/v1/player/search`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1SearchPlayerRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set a config
         * @param {V1SetConfigRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setConfig(body: V1SetConfigRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling setConfig.');
            }
            const localVarPath = `/v1/config`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1SetConfigRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Split stack
         * @param {V1SplitStackRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        splitStack(body: V1SplitStackRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling splitStack.');
            }
            const localVarPath = `/v1/storage/split/stack`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1SplitStackRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a currency
         * @param {string} currencyId 
         * @param {V1UpdateCurrencyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCurrency(currencyId: string, body: V1UpdateCurrencyRequest, options: any = {}): FetchArgs {
            // verify required parameter 'currencyId' is not null or undefined
            if (currencyId === null || currencyId === undefined) {
                throw new RequiredError('currencyId','Required parameter currencyId was null or undefined when calling updateCurrency.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateCurrency.');
            }
            const localVarPath = `/v1/currency/{currency_id}`
                .replace(`{${"currency_id"}}`, encodeURIComponent(String(currencyId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1UpdateCurrencyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an Item
         * @param {string} itemId 
         * @param {V1UpdateItemRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItem(itemId: string, body: V1UpdateItemRequest, options: any = {}): FetchArgs {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling updateItem.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateItem.');
            }
            const localVarPath = `/v1/item/{item_id}`
                .replace(`{${"item_id"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1UpdateItemRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a player
         * @param {string} playerId 
         * @param {V1UpdatePlayerRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePlayer(playerId: string, body: V1UpdatePlayerRequest, options: any = {}): FetchArgs {
            // verify required parameter 'playerId' is not null or undefined
            if (playerId === null || playerId === undefined) {
                throw new RequiredError('playerId','Required parameter playerId was null or undefined when calling updatePlayer.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updatePlayer.');
            }
            const localVarPath = `/v1/player/{player_id}`
                .replace(`{${"player_id"}}`, encodeURIComponent(String(playerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1UpdatePlayerRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a product
         * @param {string} productId 
         * @param {V1UpdateProductRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProduct(productId: string, body: V1UpdateProductRequest, options: any = {}): FetchArgs {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling updateProduct.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateProduct.');
            }
            const localVarPath = `/v1/product/{product_id}`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1UpdateProductRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a shop
         * @param {string} shopId 
         * @param {V1UpdateShopRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShop(shopId: string, body: V1UpdateShopRequest, options: any = {}): FetchArgs {
            // verify required parameter 'shopId' is not null or undefined
            if (shopId === null || shopId === undefined) {
                throw new RequiredError('shopId','Required parameter shopId was null or undefined when calling updateShop.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateShop.');
            }
            const localVarPath = `/v1/shop/{shop_id}`
                .replace(`{${"shop_id"}}`, encodeURIComponent(String(shopId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1UpdateShopRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Storage
         * @param {string} storageId 
         * @param {V1UpdateStorageRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStorage(storageId: string, body: V1UpdateStorageRequest, options: any = {}): FetchArgs {
            // verify required parameter 'storageId' is not null or undefined
            if (storageId === null || storageId === undefined) {
                throw new RequiredError('storageId','Required parameter storageId was null or undefined when calling updateStorage.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateStorage.');
            }
            const localVarPath = `/v1/storage/{storage_id}`
                .replace(`{${"storage_id"}}`, encodeURIComponent(String(storageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1UpdateStorageRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EconomyServiceApi - functional programming interface
 * @export
 */
export const EconomyServiceApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Assigns a permission
         * @param {V1AssignPermissionRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignPermission(body: V1AssignPermissionRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1AssignPermissionResponse> {
            const localVarFetchArgs = EconomyServiceApiFetchParamCreator(configuration).assignPermission(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Attach currency to a product
         * @param {V1AttachCurrencyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachCurrency(body: V1AttachCurrencyRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1AttachCurrencyResponse> {
            const localVarFetchArgs = EconomyServiceApiFetchParamCreator(configuration).attachCurrency(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Attach item to a product
         * @param {V1AttachItemRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachItem(body: V1AttachItemRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1AttachItemResponse> {
            const localVarFetchArgs = EconomyServiceApiFetchParamCreator(configuration).attachItem(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Attach currency to a Price
         * @param {V1AttachPriceCurrencyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachPriceCurrency(body: V1AttachPriceCurrencyRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1AttachPriceCurrencyResponse> {
            const localVarFetchArgs = EconomyServiceApiFetchParamCreator(configuration).attachPriceCurrency(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Attach item to a Price
         * @param {V1AttachPriceItemRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachPriceItem(body: V1AttachPriceItemRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1AttachPriceItemResponse> {
            const localVarFetchArgs = EconomyServiceApiFetchParamCreator(configuration).attachPriceItem(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Attach product to a shop
         * @param {V1AttachProductRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachProduct(body: V1AttachProductRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1AttachProductResponse> {
            const localVarFetchArgs = EconomyServiceApiFetchParamCreator(configuration).attachProduct(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Authenticate an account
         * @param {V1AuthenticateRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticate(body: V1AuthenticateRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1AuthenticateResponse> {
            const localVarFetchArgs = EconomyServiceApiFetchParamCreator(configuration).authenticate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Buy product from the store
         * @param {V1BuyProductRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buyProduct(body: V1BuyProductRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1BuyProductResponse> {
            const localVarFetchArgs = EconomyServiceApiFetchParamCreator(configuration).buyProduct(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Change password
         * @param {V1ChangePasswordRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword(body: V1ChangePasswordRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ChangePasswordResponse> {
            const localVarFetchArgs = EconomyServiceApiFetchParamCreator(configuration).changePassword(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create a currency
         * @param {V1CreateCurrencyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCurrency(body: V1CreateCurrencyRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1CreateCurrencyResponse> {
            const localVarFetchArgs = EconomyServiceApiFetchParamCreator(configuration).createCurrency(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create an Item
         * @param {V1CreateItemRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItem(body: V1CreateItemRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1CreateItemResponse> {
            const localVarFetchArgs = EconomyServiceApiFetchParamCreator(configuration).createItem(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create a player
         * @param {V1CreatePlayerRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPlayer(body: V1CreatePlayerRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1CreatePlayerResponse> {
            const localVarFetchArgs = EconomyServiceApiFetchParamCreator(configuration).createPlayer(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create a price
         * @param {V1CreatePriceRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPrice(body: V1CreatePriceRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1CreatePriceResponse> {
            const localVarFetchArgs = EconomyServiceApiFetchParamCreator(configuration).createPrice(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create a product
         * @param {V1CreateProductRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProduct(body: V1CreateProductRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1CreateProductResponse> {
            const localVarFetchArgs = EconomyServiceApiFetchParamCreator(configuration).createProduct(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create a shop
         * @param {V1CreateShopRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createShop(body: V1CreateShopRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1CreateShopResponse> {
            const localVarFetchArgs = EconomyServiceApiFetchParamCreator(configuration).createShop(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create a new Storage
         * @param {V1CreateStorageRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStorage(body: V1CreateStorageRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1CreateStorageResponse> {
            const localVarFetchArgs = EconomyServiceApiFetchParamCreator(configuration).createStorage(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete a price
         * @param {string} priceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePrice(priceId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1DeletePriceResponse> {
            const localVarFetchArgs = EconomyServiceApiFetchParamCreator(configuration).deletePrice(priceId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Detach currency from a product
         * @param {string} productCurrencyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detachCurrency(productCurrencyId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1DetachCurrencyResponse> {
            const localVarFetchArgs = EconomyServiceApiFetchParamCreator(configuration).detachCurrency(productCurrencyId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Detach item from a product
         * @param {string} productItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detachItem(productItemId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1DetachItemResponse> {
            const localVarFetchArgs = EconomyServiceApiFetchParamCreator(configuration).detachItem(productItemId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Detach currency from a Price
         * @param {string} priceCurrencyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detachPriceCurrency(priceCurrencyId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1DetachPriceCurrencyResponse> {
            const localVarFetchArgs = EconomyServiceApiFetchParamCreator(configuration).detachPriceCurrency(priceCurrencyId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Detach item to a Price
         * @param {string} priceItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detachPriceItem(priceItemId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1DetachPriceItemResponse> {
            const localVarFetchArgs = EconomyServiceApiFetchParamCreator(configuration).detachPriceItem(priceItemId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Detach product from a shop
         * @param {string} shopProductId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detachProduct(shopProductId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1DetachProductResponse> {
            const localVarFetchArgs = EconomyServiceApiFetchParamCreator(configuration).detachProduct(shopProductId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary GenerateSecret a long lived JWT
         * @param {V1GenerateSecretRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateSecret(body: V1GenerateSecretRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GenerateSecretResponse> {
            const localVarFetchArgs = EconomyServiceApiFetchParamCreator(configuration).generateSecret(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get an accounts
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount(accountId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetAccountResponse> {
            const localVarFetchArgs = EconomyServiceApiFetchParamCreator(configuration).getAccount(accountId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a config
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfig(key: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetConfigResponse> {
            const localVarFetchArgs = EconomyServiceApiFetchParamCreator(configuration).getConfig(key, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a currency
         * @param {string} currencyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrency(currencyId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetCurrencyResponse> {
            const localVarFetchArgs = EconomyServiceApiFetchParamCreator(configuration).getCurrency(currencyId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get an Item
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItem(itemId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetItemResponse> {
            const localVarFetchArgs = EconomyServiceApiFetchParamCreator(configuration).getItem(itemId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary To see what Storages belong to an User
         * @param {string} playerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayer(playerId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetPlayerResponse> {
            const localVarFetchArgs = EconomyServiceApiFetchParamCreator(configuration).getPlayer(playerId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a Price
         * @param {string} priceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPrice(priceId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetPriceResponse> {
            const localVarFetchArgs = EconomyServiceApiFetchParamCreator(configuration).getPrice(priceId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a product
         * @param {string} productId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProduct(productId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetProductResponse> {
            const localVarFetchArgs = EconomyServiceApiFetchParamCreator(configuration).getProduct(productId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a shop
         * @param {string} shopId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShop(shopId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetShopResponse> {
            const localVarFetchArgs = EconomyServiceApiFetchParamCreator(configuration).getShop(shopId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the contents of a storage
         * @param {string} storageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorage(storageId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GetStorageResponse> {
            const localVarFetchArgs = EconomyServiceApiFetchParamCreator(configuration).getStorage(storageId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Give an amount of Currency to a Storage
         * @param {V1GiveCurrencyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giveCurrency(body: V1GiveCurrencyRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GiveCurrencyResponse> {
            const localVarFetchArgs = EconomyServiceApiFetchParamCreator(configuration).giveCurrency(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Give Item to a Storage
         * @param {V1GiveItemRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giveItem(body: V1GiveItemRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1GiveItemResponse> {
            const localVarFetchArgs = EconomyServiceApiFetchParamCreator(configuration).giveItem(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List all accounts
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccount(pageSize?: number, pageToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListAccountResponse> {
            const localVarFetchArgs = EconomyServiceApiFetchParamCreator(configuration).listAccount(pageSize, pageToken, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List all configs
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConfig(pageSize?: number, pageToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListConfigResponse> {
            const localVarFetchArgs = EconomyServiceApiFetchParamCreator(configuration).listConfig(pageSize, pageToken, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Shows all currencies
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCurrency(pageSize?: number, pageToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListCurrencyResponse> {
            const localVarFetchArgs = EconomyServiceApiFetchParamCreator(configuration).listCurrency(pageSize, pageToken, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List all Items
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listItem(pageSize?: number, pageToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListItemResponse> {
            const localVarFetchArgs = EconomyServiceApiFetchParamCreator(configuration).listItem(pageSize, pageToken, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List all players
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPlayer(pageSize?: number, pageToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListPlayerResponse> {
            const localVarFetchArgs = EconomyServiceApiFetchParamCreator(configuration).listPlayer(pageSize, pageToken, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List all product
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProduct(pageSize?: number, pageToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListProductResponse> {
            const localVarFetchArgs = EconomyServiceApiFetchParamCreator(configuration).listProduct(pageSize, pageToken, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create a price
         * @param {string} productId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProductPrice(productId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListProductPriceResponse> {
            const localVarFetchArgs = EconomyServiceApiFetchParamCreator(configuration).listProductPrice(productId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List all shops
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listShop(pageSize?: number, pageToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListShopResponse> {
            const localVarFetchArgs = EconomyServiceApiFetchParamCreator(configuration).listShop(pageSize, pageToken, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List all storages
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listStorage(pageSize?: number, pageToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListStorageResponse> {
            const localVarFetchArgs = EconomyServiceApiFetchParamCreator(configuration).listStorage(pageSize, pageToken, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Merge stack
         * @param {V1MergeStackRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeStack(body: V1MergeStackRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1MergeStackResponse> {
            const localVarFetchArgs = EconomyServiceApiFetchParamCreator(configuration).mergeStack(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Refresh a token
         * @param {V1RefreshRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refresh(body: V1RefreshRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1RefreshResponse> {
            const localVarFetchArgs = EconomyServiceApiFetchParamCreator(configuration).refresh(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Register an account
         * @param {V1RegisterRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(body: V1RegisterRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1RegisterResponse> {
            const localVarFetchArgs = EconomyServiceApiFetchParamCreator(configuration).register(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Revokes a permission
         * @param {V1RevokePermissionRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokePermission(body: V1RevokePermissionRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1RevokePermissionResponse> {
            const localVarFetchArgs = EconomyServiceApiFetchParamCreator(configuration).revokePermission(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Search item
         * @param {V1SearchItemRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchItem(body: V1SearchItemRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1SearchItemResponse> {
            const localVarFetchArgs = EconomyServiceApiFetchParamCreator(configuration).searchItem(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Search player
         * @param {V1SearchPlayerRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPlayer(body: V1SearchPlayerRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1SearchPlayerResponse> {
            const localVarFetchArgs = EconomyServiceApiFetchParamCreator(configuration).searchPlayer(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set a config
         * @param {V1SetConfigRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setConfig(body: V1SetConfigRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1SetConfigResponse> {
            const localVarFetchArgs = EconomyServiceApiFetchParamCreator(configuration).setConfig(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Split stack
         * @param {V1SplitStackRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        splitStack(body: V1SplitStackRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1SplitStackResponse> {
            const localVarFetchArgs = EconomyServiceApiFetchParamCreator(configuration).splitStack(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update a currency
         * @param {string} currencyId 
         * @param {V1UpdateCurrencyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCurrency(currencyId: string, body: V1UpdateCurrencyRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1UpdateCurrencyResponse> {
            const localVarFetchArgs = EconomyServiceApiFetchParamCreator(configuration).updateCurrency(currencyId, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update an Item
         * @param {string} itemId 
         * @param {V1UpdateItemRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItem(itemId: string, body: V1UpdateItemRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1UpdateItemResponse> {
            const localVarFetchArgs = EconomyServiceApiFetchParamCreator(configuration).updateItem(itemId, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update a player
         * @param {string} playerId 
         * @param {V1UpdatePlayerRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePlayer(playerId: string, body: V1UpdatePlayerRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1UpdatePlayerResponse> {
            const localVarFetchArgs = EconomyServiceApiFetchParamCreator(configuration).updatePlayer(playerId, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update a product
         * @param {string} productId 
         * @param {V1UpdateProductRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProduct(productId: string, body: V1UpdateProductRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1UpdateProductResponse> {
            const localVarFetchArgs = EconomyServiceApiFetchParamCreator(configuration).updateProduct(productId, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update a shop
         * @param {string} shopId 
         * @param {V1UpdateShopRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShop(shopId: string, body: V1UpdateShopRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1UpdateShopResponse> {
            const localVarFetchArgs = EconomyServiceApiFetchParamCreator(configuration).updateShop(shopId, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update Storage
         * @param {string} storageId 
         * @param {V1UpdateStorageRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStorage(storageId: string, body: V1UpdateStorageRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1UpdateStorageResponse> {
            const localVarFetchArgs = EconomyServiceApiFetchParamCreator(configuration).updateStorage(storageId, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EconomyServiceApi - factory interface
 * @export
 */
export const EconomyServiceApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Assigns a permission
         * @param {V1AssignPermissionRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignPermission(body: V1AssignPermissionRequest, options?: any) {
            return EconomyServiceApiFp(configuration).assignPermission(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Attach currency to a product
         * @param {V1AttachCurrencyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachCurrency(body: V1AttachCurrencyRequest, options?: any) {
            return EconomyServiceApiFp(configuration).attachCurrency(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Attach item to a product
         * @param {V1AttachItemRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachItem(body: V1AttachItemRequest, options?: any) {
            return EconomyServiceApiFp(configuration).attachItem(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Attach currency to a Price
         * @param {V1AttachPriceCurrencyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachPriceCurrency(body: V1AttachPriceCurrencyRequest, options?: any) {
            return EconomyServiceApiFp(configuration).attachPriceCurrency(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Attach item to a Price
         * @param {V1AttachPriceItemRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachPriceItem(body: V1AttachPriceItemRequest, options?: any) {
            return EconomyServiceApiFp(configuration).attachPriceItem(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Attach product to a shop
         * @param {V1AttachProductRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachProduct(body: V1AttachProductRequest, options?: any) {
            return EconomyServiceApiFp(configuration).attachProduct(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Authenticate an account
         * @param {V1AuthenticateRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticate(body: V1AuthenticateRequest, options?: any) {
            return EconomyServiceApiFp(configuration).authenticate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Buy product from the store
         * @param {V1BuyProductRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buyProduct(body: V1BuyProductRequest, options?: any) {
            return EconomyServiceApiFp(configuration).buyProduct(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Change password
         * @param {V1ChangePasswordRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword(body: V1ChangePasswordRequest, options?: any) {
            return EconomyServiceApiFp(configuration).changePassword(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a currency
         * @param {V1CreateCurrencyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCurrency(body: V1CreateCurrencyRequest, options?: any) {
            return EconomyServiceApiFp(configuration).createCurrency(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create an Item
         * @param {V1CreateItemRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItem(body: V1CreateItemRequest, options?: any) {
            return EconomyServiceApiFp(configuration).createItem(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a player
         * @param {V1CreatePlayerRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPlayer(body: V1CreatePlayerRequest, options?: any) {
            return EconomyServiceApiFp(configuration).createPlayer(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a price
         * @param {V1CreatePriceRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPrice(body: V1CreatePriceRequest, options?: any) {
            return EconomyServiceApiFp(configuration).createPrice(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a product
         * @param {V1CreateProductRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProduct(body: V1CreateProductRequest, options?: any) {
            return EconomyServiceApiFp(configuration).createProduct(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a shop
         * @param {V1CreateShopRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createShop(body: V1CreateShopRequest, options?: any) {
            return EconomyServiceApiFp(configuration).createShop(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a new Storage
         * @param {V1CreateStorageRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStorage(body: V1CreateStorageRequest, options?: any) {
            return EconomyServiceApiFp(configuration).createStorage(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a price
         * @param {string} priceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePrice(priceId: string, options?: any) {
            return EconomyServiceApiFp(configuration).deletePrice(priceId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Detach currency from a product
         * @param {string} productCurrencyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detachCurrency(productCurrencyId: string, options?: any) {
            return EconomyServiceApiFp(configuration).detachCurrency(productCurrencyId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Detach item from a product
         * @param {string} productItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detachItem(productItemId: string, options?: any) {
            return EconomyServiceApiFp(configuration).detachItem(productItemId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Detach currency from a Price
         * @param {string} priceCurrencyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detachPriceCurrency(priceCurrencyId: string, options?: any) {
            return EconomyServiceApiFp(configuration).detachPriceCurrency(priceCurrencyId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Detach item to a Price
         * @param {string} priceItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detachPriceItem(priceItemId: string, options?: any) {
            return EconomyServiceApiFp(configuration).detachPriceItem(priceItemId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Detach product from a shop
         * @param {string} shopProductId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detachProduct(shopProductId: string, options?: any) {
            return EconomyServiceApiFp(configuration).detachProduct(shopProductId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary GenerateSecret a long lived JWT
         * @param {V1GenerateSecretRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateSecret(body: V1GenerateSecretRequest, options?: any) {
            return EconomyServiceApiFp(configuration).generateSecret(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get an accounts
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount(accountId: string, options?: any) {
            return EconomyServiceApiFp(configuration).getAccount(accountId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a config
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfig(key: string, options?: any) {
            return EconomyServiceApiFp(configuration).getConfig(key, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a currency
         * @param {string} currencyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrency(currencyId: string, options?: any) {
            return EconomyServiceApiFp(configuration).getCurrency(currencyId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get an Item
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItem(itemId: string, options?: any) {
            return EconomyServiceApiFp(configuration).getItem(itemId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary To see what Storages belong to an User
         * @param {string} playerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayer(playerId: string, options?: any) {
            return EconomyServiceApiFp(configuration).getPlayer(playerId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a Price
         * @param {string} priceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPrice(priceId: string, options?: any) {
            return EconomyServiceApiFp(configuration).getPrice(priceId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a product
         * @param {string} productId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProduct(productId: string, options?: any) {
            return EconomyServiceApiFp(configuration).getProduct(productId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a shop
         * @param {string} shopId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShop(shopId: string, options?: any) {
            return EconomyServiceApiFp(configuration).getShop(shopId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the contents of a storage
         * @param {string} storageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorage(storageId: string, options?: any) {
            return EconomyServiceApiFp(configuration).getStorage(storageId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Give an amount of Currency to a Storage
         * @param {V1GiveCurrencyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giveCurrency(body: V1GiveCurrencyRequest, options?: any) {
            return EconomyServiceApiFp(configuration).giveCurrency(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Give Item to a Storage
         * @param {V1GiveItemRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giveItem(body: V1GiveItemRequest, options?: any) {
            return EconomyServiceApiFp(configuration).giveItem(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List all accounts
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccount(pageSize?: number, pageToken?: string, options?: any) {
            return EconomyServiceApiFp(configuration).listAccount(pageSize, pageToken, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List all configs
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConfig(pageSize?: number, pageToken?: string, options?: any) {
            return EconomyServiceApiFp(configuration).listConfig(pageSize, pageToken, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Shows all currencies
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCurrency(pageSize?: number, pageToken?: string, options?: any) {
            return EconomyServiceApiFp(configuration).listCurrency(pageSize, pageToken, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List all Items
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listItem(pageSize?: number, pageToken?: string, options?: any) {
            return EconomyServiceApiFp(configuration).listItem(pageSize, pageToken, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List all players
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPlayer(pageSize?: number, pageToken?: string, options?: any) {
            return EconomyServiceApiFp(configuration).listPlayer(pageSize, pageToken, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List all product
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProduct(pageSize?: number, pageToken?: string, options?: any) {
            return EconomyServiceApiFp(configuration).listProduct(pageSize, pageToken, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a price
         * @param {string} productId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProductPrice(productId: string, options?: any) {
            return EconomyServiceApiFp(configuration).listProductPrice(productId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List all shops
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listShop(pageSize?: number, pageToken?: string, options?: any) {
            return EconomyServiceApiFp(configuration).listShop(pageSize, pageToken, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List all storages
         * @param {number} [pageSize] 
         * @param {string} [pageToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listStorage(pageSize?: number, pageToken?: string, options?: any) {
            return EconomyServiceApiFp(configuration).listStorage(pageSize, pageToken, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Merge stack
         * @param {V1MergeStackRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeStack(body: V1MergeStackRequest, options?: any) {
            return EconomyServiceApiFp(configuration).mergeStack(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Refresh a token
         * @param {V1RefreshRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refresh(body: V1RefreshRequest, options?: any) {
            return EconomyServiceApiFp(configuration).refresh(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Register an account
         * @param {V1RegisterRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(body: V1RegisterRequest, options?: any) {
            return EconomyServiceApiFp(configuration).register(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Revokes a permission
         * @param {V1RevokePermissionRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokePermission(body: V1RevokePermissionRequest, options?: any) {
            return EconomyServiceApiFp(configuration).revokePermission(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Search item
         * @param {V1SearchItemRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchItem(body: V1SearchItemRequest, options?: any) {
            return EconomyServiceApiFp(configuration).searchItem(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Search player
         * @param {V1SearchPlayerRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPlayer(body: V1SearchPlayerRequest, options?: any) {
            return EconomyServiceApiFp(configuration).searchPlayer(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set a config
         * @param {V1SetConfigRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setConfig(body: V1SetConfigRequest, options?: any) {
            return EconomyServiceApiFp(configuration).setConfig(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Split stack
         * @param {V1SplitStackRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        splitStack(body: V1SplitStackRequest, options?: any) {
            return EconomyServiceApiFp(configuration).splitStack(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a currency
         * @param {string} currencyId 
         * @param {V1UpdateCurrencyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCurrency(currencyId: string, body: V1UpdateCurrencyRequest, options?: any) {
            return EconomyServiceApiFp(configuration).updateCurrency(currencyId, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an Item
         * @param {string} itemId 
         * @param {V1UpdateItemRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItem(itemId: string, body: V1UpdateItemRequest, options?: any) {
            return EconomyServiceApiFp(configuration).updateItem(itemId, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a player
         * @param {string} playerId 
         * @param {V1UpdatePlayerRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePlayer(playerId: string, body: V1UpdatePlayerRequest, options?: any) {
            return EconomyServiceApiFp(configuration).updatePlayer(playerId, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a product
         * @param {string} productId 
         * @param {V1UpdateProductRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProduct(productId: string, body: V1UpdateProductRequest, options?: any) {
            return EconomyServiceApiFp(configuration).updateProduct(productId, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a shop
         * @param {string} shopId 
         * @param {V1UpdateShopRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShop(shopId: string, body: V1UpdateShopRequest, options?: any) {
            return EconomyServiceApiFp(configuration).updateShop(shopId, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update Storage
         * @param {string} storageId 
         * @param {V1UpdateStorageRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStorage(storageId: string, body: V1UpdateStorageRequest, options?: any) {
            return EconomyServiceApiFp(configuration).updateStorage(storageId, body, options)(fetch, basePath);
        },
    };
};

/**
 * EconomyServiceApi - object-oriented interface
 * @export
 * @class EconomyServiceApi
 * @extends {BaseAPI}
 */
export class EconomyServiceApi extends BaseAPI {
    /**
     * 
     * @summary Assigns a permission
     * @param {V1AssignPermissionRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyServiceApi
     */
    public assignPermission(body: V1AssignPermissionRequest, options?: any) {
        return EconomyServiceApiFp(this.configuration).assignPermission(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Attach currency to a product
     * @param {V1AttachCurrencyRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyServiceApi
     */
    public attachCurrency(body: V1AttachCurrencyRequest, options?: any) {
        return EconomyServiceApiFp(this.configuration).attachCurrency(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Attach item to a product
     * @param {V1AttachItemRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyServiceApi
     */
    public attachItem(body: V1AttachItemRequest, options?: any) {
        return EconomyServiceApiFp(this.configuration).attachItem(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Attach currency to a Price
     * @param {V1AttachPriceCurrencyRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyServiceApi
     */
    public attachPriceCurrency(body: V1AttachPriceCurrencyRequest, options?: any) {
        return EconomyServiceApiFp(this.configuration).attachPriceCurrency(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Attach item to a Price
     * @param {V1AttachPriceItemRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyServiceApi
     */
    public attachPriceItem(body: V1AttachPriceItemRequest, options?: any) {
        return EconomyServiceApiFp(this.configuration).attachPriceItem(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Attach product to a shop
     * @param {V1AttachProductRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyServiceApi
     */
    public attachProduct(body: V1AttachProductRequest, options?: any) {
        return EconomyServiceApiFp(this.configuration).attachProduct(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Authenticate an account
     * @param {V1AuthenticateRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyServiceApi
     */
    public authenticate(body: V1AuthenticateRequest, options?: any) {
        return EconomyServiceApiFp(this.configuration).authenticate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Buy product from the store
     * @param {V1BuyProductRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyServiceApi
     */
    public buyProduct(body: V1BuyProductRequest, options?: any) {
        return EconomyServiceApiFp(this.configuration).buyProduct(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Change password
     * @param {V1ChangePasswordRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyServiceApi
     */
    public changePassword(body: V1ChangePasswordRequest, options?: any) {
        return EconomyServiceApiFp(this.configuration).changePassword(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create a currency
     * @param {V1CreateCurrencyRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyServiceApi
     */
    public createCurrency(body: V1CreateCurrencyRequest, options?: any) {
        return EconomyServiceApiFp(this.configuration).createCurrency(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create an Item
     * @param {V1CreateItemRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyServiceApi
     */
    public createItem(body: V1CreateItemRequest, options?: any) {
        return EconomyServiceApiFp(this.configuration).createItem(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create a player
     * @param {V1CreatePlayerRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyServiceApi
     */
    public createPlayer(body: V1CreatePlayerRequest, options?: any) {
        return EconomyServiceApiFp(this.configuration).createPlayer(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create a price
     * @param {V1CreatePriceRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyServiceApi
     */
    public createPrice(body: V1CreatePriceRequest, options?: any) {
        return EconomyServiceApiFp(this.configuration).createPrice(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create a product
     * @param {V1CreateProductRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyServiceApi
     */
    public createProduct(body: V1CreateProductRequest, options?: any) {
        return EconomyServiceApiFp(this.configuration).createProduct(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create a shop
     * @param {V1CreateShopRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyServiceApi
     */
    public createShop(body: V1CreateShopRequest, options?: any) {
        return EconomyServiceApiFp(this.configuration).createShop(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create a new Storage
     * @param {V1CreateStorageRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyServiceApi
     */
    public createStorage(body: V1CreateStorageRequest, options?: any) {
        return EconomyServiceApiFp(this.configuration).createStorage(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete a price
     * @param {string} priceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyServiceApi
     */
    public deletePrice(priceId: string, options?: any) {
        return EconomyServiceApiFp(this.configuration).deletePrice(priceId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Detach currency from a product
     * @param {string} productCurrencyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyServiceApi
     */
    public detachCurrency(productCurrencyId: string, options?: any) {
        return EconomyServiceApiFp(this.configuration).detachCurrency(productCurrencyId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Detach item from a product
     * @param {string} productItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyServiceApi
     */
    public detachItem(productItemId: string, options?: any) {
        return EconomyServiceApiFp(this.configuration).detachItem(productItemId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Detach currency from a Price
     * @param {string} priceCurrencyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyServiceApi
     */
    public detachPriceCurrency(priceCurrencyId: string, options?: any) {
        return EconomyServiceApiFp(this.configuration).detachPriceCurrency(priceCurrencyId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Detach item to a Price
     * @param {string} priceItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyServiceApi
     */
    public detachPriceItem(priceItemId: string, options?: any) {
        return EconomyServiceApiFp(this.configuration).detachPriceItem(priceItemId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Detach product from a shop
     * @param {string} shopProductId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyServiceApi
     */
    public detachProduct(shopProductId: string, options?: any) {
        return EconomyServiceApiFp(this.configuration).detachProduct(shopProductId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary GenerateSecret a long lived JWT
     * @param {V1GenerateSecretRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyServiceApi
     */
    public generateSecret(body: V1GenerateSecretRequest, options?: any) {
        return EconomyServiceApiFp(this.configuration).generateSecret(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get an accounts
     * @param {string} accountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyServiceApi
     */
    public getAccount(accountId: string, options?: any) {
        return EconomyServiceApiFp(this.configuration).getAccount(accountId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a config
     * @param {string} key 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyServiceApi
     */
    public getConfig(key: string, options?: any) {
        return EconomyServiceApiFp(this.configuration).getConfig(key, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a currency
     * @param {string} currencyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyServiceApi
     */
    public getCurrency(currencyId: string, options?: any) {
        return EconomyServiceApiFp(this.configuration).getCurrency(currencyId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get an Item
     * @param {string} itemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyServiceApi
     */
    public getItem(itemId: string, options?: any) {
        return EconomyServiceApiFp(this.configuration).getItem(itemId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary To see what Storages belong to an User
     * @param {string} playerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyServiceApi
     */
    public getPlayer(playerId: string, options?: any) {
        return EconomyServiceApiFp(this.configuration).getPlayer(playerId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a Price
     * @param {string} priceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyServiceApi
     */
    public getPrice(priceId: string, options?: any) {
        return EconomyServiceApiFp(this.configuration).getPrice(priceId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a product
     * @param {string} productId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyServiceApi
     */
    public getProduct(productId: string, options?: any) {
        return EconomyServiceApiFp(this.configuration).getProduct(productId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a shop
     * @param {string} shopId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyServiceApi
     */
    public getShop(shopId: string, options?: any) {
        return EconomyServiceApiFp(this.configuration).getShop(shopId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the contents of a storage
     * @param {string} storageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyServiceApi
     */
    public getStorage(storageId: string, options?: any) {
        return EconomyServiceApiFp(this.configuration).getStorage(storageId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Give an amount of Currency to a Storage
     * @param {V1GiveCurrencyRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyServiceApi
     */
    public giveCurrency(body: V1GiveCurrencyRequest, options?: any) {
        return EconomyServiceApiFp(this.configuration).giveCurrency(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Give Item to a Storage
     * @param {V1GiveItemRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyServiceApi
     */
    public giveItem(body: V1GiveItemRequest, options?: any) {
        return EconomyServiceApiFp(this.configuration).giveItem(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List all accounts
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyServiceApi
     */
    public listAccount(pageSize?: number, pageToken?: string, options?: any) {
        return EconomyServiceApiFp(this.configuration).listAccount(pageSize, pageToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List all configs
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyServiceApi
     */
    public listConfig(pageSize?: number, pageToken?: string, options?: any) {
        return EconomyServiceApiFp(this.configuration).listConfig(pageSize, pageToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Shows all currencies
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyServiceApi
     */
    public listCurrency(pageSize?: number, pageToken?: string, options?: any) {
        return EconomyServiceApiFp(this.configuration).listCurrency(pageSize, pageToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List all Items
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyServiceApi
     */
    public listItem(pageSize?: number, pageToken?: string, options?: any) {
        return EconomyServiceApiFp(this.configuration).listItem(pageSize, pageToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List all players
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyServiceApi
     */
    public listPlayer(pageSize?: number, pageToken?: string, options?: any) {
        return EconomyServiceApiFp(this.configuration).listPlayer(pageSize, pageToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List all product
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyServiceApi
     */
    public listProduct(pageSize?: number, pageToken?: string, options?: any) {
        return EconomyServiceApiFp(this.configuration).listProduct(pageSize, pageToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create a price
     * @param {string} productId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyServiceApi
     */
    public listProductPrice(productId: string, options?: any) {
        return EconomyServiceApiFp(this.configuration).listProductPrice(productId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List all shops
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyServiceApi
     */
    public listShop(pageSize?: number, pageToken?: string, options?: any) {
        return EconomyServiceApiFp(this.configuration).listShop(pageSize, pageToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List all storages
     * @param {number} [pageSize] 
     * @param {string} [pageToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyServiceApi
     */
    public listStorage(pageSize?: number, pageToken?: string, options?: any) {
        return EconomyServiceApiFp(this.configuration).listStorage(pageSize, pageToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Merge stack
     * @param {V1MergeStackRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyServiceApi
     */
    public mergeStack(body: V1MergeStackRequest, options?: any) {
        return EconomyServiceApiFp(this.configuration).mergeStack(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Refresh a token
     * @param {V1RefreshRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyServiceApi
     */
    public refresh(body: V1RefreshRequest, options?: any) {
        return EconomyServiceApiFp(this.configuration).refresh(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Register an account
     * @param {V1RegisterRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyServiceApi
     */
    public register(body: V1RegisterRequest, options?: any) {
        return EconomyServiceApiFp(this.configuration).register(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Revokes a permission
     * @param {V1RevokePermissionRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyServiceApi
     */
    public revokePermission(body: V1RevokePermissionRequest, options?: any) {
        return EconomyServiceApiFp(this.configuration).revokePermission(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Search item
     * @param {V1SearchItemRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyServiceApi
     */
    public searchItem(body: V1SearchItemRequest, options?: any) {
        return EconomyServiceApiFp(this.configuration).searchItem(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Search player
     * @param {V1SearchPlayerRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyServiceApi
     */
    public searchPlayer(body: V1SearchPlayerRequest, options?: any) {
        return EconomyServiceApiFp(this.configuration).searchPlayer(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set a config
     * @param {V1SetConfigRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyServiceApi
     */
    public setConfig(body: V1SetConfigRequest, options?: any) {
        return EconomyServiceApiFp(this.configuration).setConfig(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Split stack
     * @param {V1SplitStackRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyServiceApi
     */
    public splitStack(body: V1SplitStackRequest, options?: any) {
        return EconomyServiceApiFp(this.configuration).splitStack(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update a currency
     * @param {string} currencyId 
     * @param {V1UpdateCurrencyRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyServiceApi
     */
    public updateCurrency(currencyId: string, body: V1UpdateCurrencyRequest, options?: any) {
        return EconomyServiceApiFp(this.configuration).updateCurrency(currencyId, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update an Item
     * @param {string} itemId 
     * @param {V1UpdateItemRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyServiceApi
     */
    public updateItem(itemId: string, body: V1UpdateItemRequest, options?: any) {
        return EconomyServiceApiFp(this.configuration).updateItem(itemId, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update a player
     * @param {string} playerId 
     * @param {V1UpdatePlayerRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyServiceApi
     */
    public updatePlayer(playerId: string, body: V1UpdatePlayerRequest, options?: any) {
        return EconomyServiceApiFp(this.configuration).updatePlayer(playerId, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update a product
     * @param {string} productId 
     * @param {V1UpdateProductRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyServiceApi
     */
    public updateProduct(productId: string, body: V1UpdateProductRequest, options?: any) {
        return EconomyServiceApiFp(this.configuration).updateProduct(productId, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update a shop
     * @param {string} shopId 
     * @param {V1UpdateShopRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyServiceApi
     */
    public updateShop(shopId: string, body: V1UpdateShopRequest, options?: any) {
        return EconomyServiceApiFp(this.configuration).updateShop(shopId, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update Storage
     * @param {string} storageId 
     * @param {V1UpdateStorageRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyServiceApi
     */
    public updateStorage(storageId: string, body: V1UpdateStorageRequest, options?: any) {
        return EconomyServiceApiFp(this.configuration).updateStorage(storageId, body, options)(this.fetch, this.basePath);
    }

}

